extend schema
@remote(name: "V3")
@base_action(name: "v3_action")
@base_action_field(name: "action", type: "String", description: "The name of this action. (This should match its action name in figment). Only used for {V3} actions that are not endpoints.")
@base_action_field(deprecated: true, name: "context", type: "ActionContext", required: false, description: "Optional. Analytics context info to include in the action. Only used for {V3} actions that are not endpoints. When sending to {V3}, do not send this field as an object, instead all of the fields of this {ActionContext} should be included side by side other parameters in the action json. Deprecated in favor of {SnowplowEntity}.")
"""
String in format of an email address
"""
scalar EmailAddress

"""
A file to be uploaded. When passing to v3, use a Content-Disposition multipart header TODO give concrete example, but looks something like "Content-Disposition", "form-data; name=THE_PARAMETER_NAME; filename=THE_IMAGE_FILE_NAME" where for example on the {setAvatar} endpoint THE_PARAMETER_NAME is `image`
"""
scalar FileField

"""
Raw structured data that should not be parsed into anything. In JSON this is an Object {}. In general everything should be defined as a Thing so this should only be used in special cases.
"""
scalar Data

"""
String that represents a hex color, such as "#FFFFFF".   Alpha channel optionally supported: #FFFFFFFF
"""
scalar HexColor

"""
A String. A user access token. Client's should take special care should be taken to store it securely and make sure it does not appear in logs.
"""
scalar AccessToken

"""
A String. A user's password. Client's should never persist this and only pass it directly to the server at the time it is needed. Do not expose in logs.
"""
scalar Password

"""
A String that may have escaped characters and likely needs to be unescaped before displaying in ui.
"""
scalar EscapedString

"""
A String that may contain a limited set of html tags for formatting like for bold, italic, etc. TODO what subset is supported?
"""
scalar HtmlString

"""
A string that contains html markup. Also see {HtmlString} for when a smaller subset of tags is only needed.
"""
scalar Html

extend type Item @figment(related_to: "SaveForLaterFeature") @figment(related_to: "DiscoverFeature")
@extend(field: "domain", reactive: ".display_url", instructions: "This can be calculated by reducing {.display_url} down to the host part, removing slashes, and any `www.` subdomain. Other subdomains are fine to keep.\nOriginally it said to base this on {.resolved_url}, but it's not always available and {.display_url} has all the needed fallback logic.")
{
    """
    The url to use to identify the item, such as when actions ask for a url.
    Ideally we'd just make {.given_url} the identity, but since there are some cases where the {V3} api might only provide a {.resolved_url}, it can't be at the moment.
    id_url is field you can rely on, but it requires you to derive it by looking at which of the two is available.

    ### Deep dive into previous research into what field to use for item identity

    An Item is essentially a saved url. When a user saves an item via {add}, the {.given_url} is the url they saved.
    When the backend looks at a url, it passes it into a normalization function that will consider some urls the same item and eliminate common duplicates.
    For example, `http://pocket.com`, `https://pocket.com` and `https://pocket.com/` can all be considered the same item.
    This normalization is the {.normal_url}. Internally the backend also hashes this and uses that hash to look up an item.
    It then assigns new/unique items a {.item_id}.  So items with the same {.normal_url} should have the same {.item_id}.
    Item's with different but similar {.given_url}s may all share a {.normal_url} and {.item_id} if the backend considers them the same.

    Early on in Pocket's history the normalization function was changed to further increase the deduplication of similar urls.
    Items that were saved and assigned {.item_id}s before this function was changed will use the old normalization
    and Item's that were saved after that change use the new normalization.

    So what field can be considered the Item's identity? Identities must be immutable and known immediately to the apps so they can save
    and work offline or immediately locally without having to talk to the server.

    {.item_id} is a great representation of what the backend considers the same item, but it is server assigned and there is
    no way for a client to know the id without talking with the backend first. So apps cannot use it as identity.

    {.normal_url} is technically the identity, and the clients could have the same normalization function implemented client side
    and generate the {.normal_url} from the {.given_url} locally. However this could be error prone if the client's don't exactly
    share the normalization function logic. Also, because of the legacy normalization function, there is no way for client's
    to know which urls should have the legacy normalize method and which should have the new one. So apps cannot use it as identity.

    {.given_url} is known to the client's immediately but in some cases, like in recommended feeds, the backend only returns a {.resolved_url}

    {.id_url} is a derived field that says to use {.given_url} if available, otherwise {.resolved_url}. This can be used fairly reliable
    as an id, since apps will always know it when saving offline or locally. However there are two cases to watch out for.
    First, {get} can return deleted items by only referencing {.item_id}. No url is provided. So apps need to handle detecting this case for this endpoint and
    and look up by item_id to find the item. They will only know the {.item_id} if they resolved from v3/send or synced the item in another way before this.
    Second, there is a corner case where the app can end up with a duplicate on their side but not the backend. The steps for this are:
    1. Save `https://nytimes.com/`, sync with the backend. The server assigns it {.item_id} `5440435`.
    2. Save `https://nytimes.com` in the app. Since it has a different {.id_url} the app perceives it as a separate item.
    3. When the app syncs with the backend, it normalizes that url and sees it as the same item you already had: {.item_id} `5440435`. So it does not add a new item, it updates the existing one.
    4. At this point the app has two items, with different {.id_url} but the same {.item_id} and the backend has one item.

    So unfortunately there is no perfect identity available. They all have their own pitfalls.
    However, the least complex and most reliable for apps to use is the {.id_url}. It will give them immutable, known immediately, identity.
    But they need to be aware of the two corner cases. Apps can elect not to bother trying to repair the duplicate case since it is a corner case
    and is resolved next time the user logs in. However, if they wanted to handle it, they would need to handle merging those items together locally.

    For further information about the various ids in an Item, see [How Items are Managed in Pocket](https://docs.google.com/document/d/1ExO0c1a3pi6aYY7lucUBWeafnzJM0X8yK45k72YF5Z4/edit)
    """
    id_url: Url @id @local @derives(first_available: [".given_url", ".resolved_url"])

    # Fields that are meta data about the item, provided by the backend, same for all users.
    "A server generated unique id for this item. Item's whose {.normal_url} are the same will have the same item_id. Most likely numeric, but to ensure future proofing this can be treated as a String in apps."
    item_id: String @figment(client_api_alias: "itemId")

    """
    A normalized value of the given_url.
    It will look like a url but is not guaranteed to be a valid url, just a unique string that is used to eliminate common duplicates.
    Item's that share a normal_url should be considered the same item. For example https://getpocket.com and http://getpocket.com will be considered the same since they both normalize to http://getpocket.com
    This is technically the true identity of an item, since this is what the backend uses to tell if two items are the same.
    However, for the clients to use this, they would all have to ship an implementation of the normalization function that the backend has exactly.
    And even if it did that, some items, some of the earliest saves, use a legacy normalize function and the client would have no way to know when to use which normalizing function.
    """
    normal_url: String @figment(client_api_alias: "normalUrl")

    # Fields that are meta data about the item, provided by the parser, same for all users.
    "If available, the url to an AMP version of this article"
    amp_url: Url @figment(client_api_alias: "ampUrl")

    "A {Group} that this item is part of"
    badge_group_id: GroupId

    "The group represented by {.badge_group_id}"
    badge: Group @local
    @derives(reactive: ".badge_group_id")
    @derives(instructions: "Find a group where {.badge_group_id} is {Group.group_id}")

    "Additional information about the item domain, when present, use this for displaying the domain name"
    domain_metadata: DomainMetadata @figment(client_api_alias: "domainMetadata")

    "0=no images, 1=contains images, 2=is an image"
    has_image: Imageness @figment(client_api_alias: "hasImage")

    "0=no videos, 1=contains video, 2=is a video"
    has_video: Videoness @figment(client_api_alias: "hasVideo")

    "Preferred thumbnail"
    image: Image

    "true if the item is an article"
    is_article: Boolean @figment(client_api_alias: "isArticle")

    "true if the item is an index / home page, rather than a specific single piece of content"
    is_index: Boolean @figment(client_api_alias: "isIndex")

    "Estimated seconds to listen to article."
    listen_duration_estimate: Int

    "The mime type of this item's web page"
    mime_type: String @figment(client_api_alias: "mimeType")

    "The item id of the resolved_url"
    resolved_id: String @figment(client_api_alias: "resolvedId")

    "If the given_url redirects (once or many times), this is the final url. Otherwise, same as given_url"
    resolved_url: Url @figment(client_api_alias: "resolvedUrl")

    "A normalized version of resolved_url"
    resolved_url_normalized: String

    "The title of the webpage. For displaying a title, prioritize as follows: resolved_title, title, given_title, resolved_url, given_url"
    resolved_title: String

    "The domain of resolved_url TODO not sure when this appears or if only as part of getItemPreview"
    resolved_domain: String

    "The page's / publisher's preferred thumbnail image"
    top_image_url: Url @figment(client_api_alias: "topImageUrl")

    "Number of words in the article"
    word_count: Int @figment(client_api_alias: "wordCount")

    "If this url/item points to a Pocket syndicated story (not pointing to the original url, but pointing to the actual syndicated story on pocket's website), this is non-null and contains meta data about that story."
    syndicated_article: SyndicatedArticle @figment(client_api_alias: "syndicatedArticle")

    "TODO docs"
    extended_item_id: String @figment(client_api_alias: "extendedItemId")

    "The primary database id of the domain this article is from"
    domain_id: String @deprecated @figment(client_api_alias: "domainId")

    "If a the domainId is a subdomain this is the primary domain id"
    origin_domain_id: String @deprecated @figment(client_api_alias: "originDomainId")

    "The http resonse code of the given url"
    response_code: String @deprecated @figment(client_api_alias: "responseCode")

    "TThe length in bytes of the content"
    content_length: String @deprecated @figment(client_api_alias: "contentLength")

    "The date the parser resolved this item"
    date_resolved: DateString @figment(client_api_alias: "dateResolved")

    "The date the article was published"
    date_published: DateString @figment(client_api_alias: "datePublished")

    "Indicates if the text of the url is a redirect to another url"
    innerdomain_redirect: Boolean @deprecated @figment(client_api_alias: "innerdomainRedirect")

    "Indicates if the url requires a login"
    login_required: Boolean @deprecated @figment(client_api_alias: "loginRequired")

    "The detected language of the article"
    lang: String @figment(client_api_alias: "language")

    "Date this item was first parsed in Pocket"
    time_first_parsed: Timestamp @deprecated @figment(client_api_alias: "timeFirstParsed")

    "The resolved url, but ran through the normalized function... is it this or {.resolved_url_normalized} ?"
    resolved_normal_url: String @deprecated @figment(client_api_alias: "resolvedNormalUrl")

    "How long it will take to read the article (TODO in what time unit? and by what calculation?)"
    time_to_read: Int @figment(client_api_alias: "timeToRead")

    "Indicates if the parser used fallback methods... is this really per item or should be remapped to {articleView} instead?"
    used_fallback: Boolean @deprecated @figment(client_api_alias: "usedFallback")

    "Indicates that the item was stored via a different search_hash (using the old method), we'll need to look up a different id"
    has_old_dupes: Boolean @deprecated @figment(client_api_alias: "hasOldDupes")

    # Fields that are specific to the logged in user, their meta data attached to this item
    "The url as provided by the user when saving. Only http or https schemes allowed."
    given_url: Url @figment(client_api_alias: "givenUrl")

    "User provided title. For displaying a title, prioritize as follows: resolved_title, title, given_title, resolved_url, given_url"
    given_title: String

    "A list of annotations/highlights the user has added to this item"
    annotations: [Annotation]

    "0=not a favorite, 1=favorited"
    favorite: Boolean

    meta: ItemMeta

    "Tweets that are attributed to this save. Clients should look at {.meta.1} for a tweet id, then load the tweet from the twitter api and set this value with a {resolve_tweet} action."
    tweets: [Tweet] @local

    "A key:value object of progress positions, the key is the view of the position, and the value is the position for that view type. See the position model for details on view types."
    positions: [Position] @map @local

    "A list of posts that are attributed to this item, such as the user saving from this post."
    posts: [Post]
    @derives(reactive: ".posts.deleted")
    @derives(instructions: "actions handle adding posts to an item.")
    @derives(instructions: "only reactive as a filter. remove a post if {Post.deleted} becomes true")

    "A list of shares attached to this. While Send to Friend is deprecated, until we provide a way for user's to download this info, we should still provide/show it in app."
    shares: [SharedItem]

    "0 based index of sort order. 0 being first. (Deprecation: Sort Ids are a pattern we should try to avoid in the future, the APIs should just return arrays in the order they are intended. This should also be remapped to the parent query, it shouldn't be here in the thing itself.)"
    sort_id: Int @deprecated

    "The save state. 0=unread, 1=archived, 2=deleted, 3=non_list_item, 4=ignored share"
    status: ItemStatus

    "A list of tags the user has added to this item"
    tags: [Tag]

    "Last time this model was added (status=0)"
    time_added: Timestamp

    "Last time this model was favorited"
    time_favorited: Timestamp

    "Last time this model was archived (status=1)"
    time_read: Timestamp

    "Time this item was deleted."
    time_deleted: Timestamp @local

    "Last time this model was changed by the user"
    time_updated: Timestamp

    # Fields that some apps may use locally and are user specific. These are not provided by the backend or parser
    "The status of whether or not the {PositionType.WEB} view has been downloaded and is available for viewing offline."
    offline_web: OfflineStatus @local

    "The status of whether or not the {PositionType.ARTICLE} view has been downloaded and is available for viewing offline."
    offline_text: OfflineStatus @local

    # Derived fields to help clarify logic for what values to use in some common cases
    "The best title for displaying the item to the user."
    display_title: String @local @derives(first_available: [".title", ".resolved_title", ".given_title", ".display_url"])

    "The best url to for displaying the item to the user. Do not use for functional purposes like opening or sharing"
    display_url: Url @local @derives(first_available: [".syndicated_article.publisher.url", ".resolved_url", ".given_url", ".id_url"])

    "The best text to display as the domain or publisher of this item, given all of the possible inputs that might be available."
    display_domain: String @local @derives(first_available: [".syndicated_article.publisher.name", ".domain_metadata.name", ".domain"])

    "The url of the best thumbnail for use when displaying this item"
    display_thumbnail: Url @local @derives(first_available: [".top_image_url", ".images[0].src"])

    "The url that should be opened in the reader or saved for offline viewing"
    open_url: Url @local @derives(first_available: [".given_url", ".id_url"])

    "The url that should be shared if the user shares this item"
    share_url: Url @local @derives(first_available: [".given_url", ".id_url"])

    "true if the item been opened in reader view"
    viewed: Boolean @local
}

extend type Mutation {
    "Save an {Item} to My List."
    add(
        "The url of the page to save. Only http and https is supported." url: Url
        "If known, the {Item.item_id}" item_id: String
        "If known, what the title of the page is." title: String
        "Optional. Any tags of to add to the item" tags: [String]
        "Optional. An id that will be passed back to you by v3\/send to help identify this in your local store. Not persisted by v3." unique_id: String @_deprecated
        "Optional. If saved from a tweet, the tweet's status id" ref_id: String
        "Same as {.ref_id}" tweet_id: String
        "If saving from a {Post}, create an {AttributionSaveInfo} (see that thing for instructions) for the post and include it here attribute the save to the post." attribution_detail: [AttributionSaveInfo]
        "If a post was attached to the attribution. See {.attribution_detail} for attaching the post info so it is attributed." post: Post @local
        "If known, can supply all of the starting item info to persist." item: Item @local
    ): Item
    @figment(related_to: "SaveForLaterFeature")
    @figment(auth: "UserAuth")
    @figment(priority: "ASAP")
    @figment(effect: "For Clients:")
    @figment(effect: "Look up an {Item} where {Item.id_url} is {.url} or {Item.item_id} is {.item_id}")
    @figment(effect: "If new, create a new {Item} with")
    @figment(effect: "  * {Item.given_title} = {.title}")
    @figment(effect: "Set {Item.status} to {ItemStatus.UNREAD}")
    @figment(effect: "Set {Item.time_added} to {.time}")
    @figment(effect: "Set {Item.time_updated} to {.time}")
    @figment(effect: "Also if {.ref_id} or {.tweet_id} is declared, then set {Item.meta.1} as that value")
    @figment(effect: "Also if {.tags} is declared, then do the same logic defined in {tags_add}")
    @figment(effect: "Also if {.attribution_detail} and {AttributionSaveInfo.attribution_type_id} is {AttributionTypeId.POST} then:")
    @figment(effect: "  * Find a {Post} where {Post.post_id} matching {AttributionSaveInfo.source_id} and add it to {Item.posts}")
}

enum ItemStatus @figment(related_to: "OrganizeFeature") {
    UNREAD @figment(enum_value: "0")
    ARCHIVED @figment(enum_value: "1")
    DELETED @figment(enum_value: "2")
    NON_LIST_ITEM @figment(enum_value: "3")
    IGNORED_SHARED @figment(enum_value: "4")
}

extend type Mutation {
    "Archive an {Item}"
    archive(
        "If known, the {Item.item_id}. At least one of {.item_id} or {.url} must be set to identify the item to act on." item_id: String
        "If known, the {Item.id_url}. At least one of {.item_id} or {.url} must be set to identify the item to act on." url: Url
    ): Void
    @figment(related_to: "ArchivingFeature")
    @figment(auth: "UserAuth")
    @figment(priority: "ASAP")
    @figment(effect: "Look up an {Item} where {Item.id_url} is {.url} or {Item.item_id} is {.item_id} and update:")
    @figment(effect: "  * {Item.status} = {ItemStatus.ARCHIVED}")
    @figment(effect: "  * {Item.time_read} = {.time}")
    @figment(effect: "  * {Item.time_updated} = {.time}")
}

extend type Mutation {
    "Undo a previous {archive}, restoring the state it was before. This may only be allowed for a short period of time after the archive, otherwise consider {readd}. This is only to indicate the user hit an undo like UI vs a Readd like UI."
    undo_archive(
        "If known, the {Item.item_id}. At least one of {.item_id} or {.url} must be set to identify the item to act on." item_id: String
        "If known, the {Item.id_url}. At least one of {.item_id} or {.url} must be set to identify the item to act on." url: Url
    ): Void
    @figment(related_to: "ArchivingFeature")
    @figment(auth: "UserAuth")
    @figment(priority: "ASAP")
    @figment(effect: "Look up an {Item} where {Item.id_url} is {.url} or {Item.item_id} is {.item_id} and update:")
    @figment(effect: "   * {Item.status} = {ItemStatus.UNREAD}")
    @figment(effect: "   * {Item.time_read} = null or 0")
}

extend type Mutation {
    "Same as {add} but meant to indicate that the user's intent was to unarchive an item they previously archived."
    readd(
        "The url of the page to save. Only http and https is supported." url: Url
        "If known, the {Item.item_id}" item_id: String
        "If known, what the title of the page is." title: String
        "Optional. Any tags of to add to the item" tags: [String]
        "Optional. An id that will be passed back to you by v3\/send to help identify this in your local store. Not persisted by v3." unique_id: String @_deprecated
        "Optional. If saved from a tweet, the tweet's status id" ref_id: String
        "Same as {.ref_id}" tweet_id: String
        "If saving from a {Post}, create an {AttributionSaveInfo} for the post and include it here attribute the save to the post." attribution_detail: [AttributionSaveInfo]
        "If a post was attached to the attribution." post: Post @local
        "If known, can supply all of the starting item info to persist." item: Item @local
    ): Item
    @figment(related_to: "SaveForLaterFeature")
    @figment(related_to: "ArchivingFeature")
    @figment(auth: "UserAuth")
    @figment(priority: "ASAP")
    @figment(effect: "do the same as an {add}")
}

extend type Mutation {
    "Delete an {Item}."
    delete(
        "If known, the {Item.item_id}. At least one of {.item_id} or {.url} must be set to identify the item to act on." item_id: String
        "If known, the {Item.id_url}. At least one of {.item_id} or {.url} must be set to identify the item to act on." url: Url
    ): Void
    @figment(related_to: "DeletingFeature")
    @figment(auth: "UserAuth")
    @figment(priority: "ASAP")
    @figment(effect: "Look up an {Item} where {Item.id_url} is {.url} or {Item.item_id} is {.item_id} and update:")
    @figment(effect: "  * {Item.status} = {ItemStatus.DELETED}")
    @figment(effect: "  * {Item.time_updated} = {.time}")
    @figment(effect: "The item may be retained for a should time to allow undoing through {undo_delete} or other readding actions, but then the data should be deleted.")
}

extend type Mutation {
    "Undo a previous {delete}, restoring the state it was before. This may only be allowed for a short period of time after the delete."
    undo_delete(
        "If known, the {Item.item_id}. At least one of {.item_id} or {.url} must be set to identify the item to act on." item_id: String
        "If known, the {Item.id_url}. At least one of {.item_id} or {.url} must be set to identify the item to act on." url: Url
        old_status: ItemStatus @local
    ): Void
    @figment(related_to: "DeletingFeature")
    @figment(auth: "UserAuth")
    @figment(priority: "ASAP")
    @figment(effect: "restore item's previous status, you can check if time_read is set to know if it was archived or not")
}

extend type Mutation {
    "Favorite an {Item}"
    favorite(
        "If known, the {Item.item_id}. At least one of {.item_id} or {.url} must be set to identify the item to act on." item_id: String
        "If known, the {Item.id_url}. At least one of {.item_id} or {.url} must be set to identify the item to act on." url: Url
    ): Void
    @figment(related_to: "FavoritingFeature")
    @figment(auth: "UserAuth")
    @figment(priority: "ASAP")
    @figment(effect: "Look up an {Item} where {Item.id_url} is {.url} or {Item.item_id} is {.item_id} and update:")
    @figment(effect: "  * {Item.favorite} = true")
    @figment(effect: "  * {Item.time_updated} = {.time}")
    @figment(effect: "  * {Item.time_favorited} = {.time}")
}

extend type Mutation {
    "Unfavorite an {Item}"
    unfavorite(
        "If known, the {Item.item_id}. At least one of {.item_id} or {.url} must be set to identify the item to act on." item_id: String
        "If known, the {Item.id_url}. At least one of {.item_id} or {.url} must be set to identify the item to act on." url: Url
    ): Void
    @figment(related_to: "FavoritingFeature")
    @figment(auth: "UserAuth")
    @figment(priority: "ASAP")
    @figment(effect: "Look up an {Item} where {Item.id_url} is {.url} or {Item.item_id} is {.item_id} and update:")
    @figment(effect: "  * {Item.favorite} = false")
    @figment(effect: "  * {Item.time_updated} = {.time}")
}

extend type Tag @figment(related_to: "TaggingFeature") {
    "Tags should have whitespace removed, then trimmed to a max of 25 characters. When matching, preserve capitalization for display purposes, but match/compare equality in a case-insensitive way. becareful to handle case-insensitive properly in all languages. Also cannot be any of the {ReservedTag} values."
    tag: String @figment(client_api_alias: "name")

    # There was a backwards incompatible change on the graph that removed these fields.
    # Keeping them as local for backwards compat, because uncompressing a tag from `DumbStorage`
    # relies on these fields being there. (Even though we don't use them.)
    "Unix timestamp of when the entity was created"
    _createdAt: Int @local
    "Unix timestamp of when the entity was last updated, if any property on the entity is modified this timestamp is set to the modified time"
    _updatedAt: Int @local
}

"""
{Tag}s that not allowed since they have special meaning in our API
"""
enum ReservedTag @figment(related_to: "TaggingFeature") {
    "A special tag that indicates filtering to only items that do not have any tags"
    _untagged_
}

extend type Mutation {
    "Add tags to an {Item}."
    tags_add(
        "If known, the {Item.item_id}. At least one of {.item_id} or {.url} must be set to identify the item to act on." item_id: String
        "If known, the {Item.given_url}. At least one of {.item_id} or {.url} must be set to identify the item to act on." url: Url
        tags: [String]
    ): Void
    @figment(related_to: "TaggingFeature")
    @figment(auth: "UserAuth")
    @figment(priority: "ASAP")
    @figment(effect: "Clean up and validate all tags based on rules defined in {Tag.tag}")
    @figment(effect: "Look up an {Item} where {Item.id_url} is {.url} or {Item.item_id} is {.item_id} and update:")
    @figment(effect: "  * Add any tags to {Item.tags} that aren't already present (case insensitive, be careful of localization when comparing case)")
    @figment(effect: "  * {Item.time_updated} = {.time}")
}

extend type Mutation {
    "Remove all tags on an {Item} and replace with new tags"
    tags_replace(
        "If known, the {Item.item_id}. At least one of {.item_id} or {.url} must be set to identify the item to act on." item_id: String
        "If known, the {Item.given_url}. At least one of {.item_id} or {.url} must be set to identify the item to act on." url: Url
        tags: [String]
    ): Void
    @figment(related_to: "TaggingFeature")
    @figment(auth: "UserAuth")
    @figment(priority: "ASAP")
    @figment(effect: "Clean up and validate all tags based on rules defined in {Tag.tag}.")
    @figment(effect: "Deduplicate cleaned up tags.")
    @figment(effect: "Look up an {Item} where {Item.id_url} is {.url} or {Item.item_id} is {.item_id} and update:")
    @figment(effect: "  * Clear {Item.tags}")
    @figment(effect: "  * Add all cleaned up and deduplicated tags.")
    @figment(effect: "  * {Item.time_updated} = {.time}")
}

extend type Mutation {
    "Remove specific tags from an {Item}"
    tags_remove(
        "If known, the {Item.item_id}. At least one of {.item_id} or {.url} must be set to identify the item to act on." item_id: String
        "If known, the {Item.given_url}. At least one of {.item_id} or {.url} must be set to identify the item to act on." url: Url
        tags: [String]
    ): Void
    @figment(related_to: "TaggingFeature")
    @figment(auth: "UserAuth")
    @figment(priority: "ASAP")
    @figment(effect: "Look up an {Item} where {Item.id_url} is {.url} or {Item.item_id} is {.item_id} and update:")
    @figment(effect: "  * Remove any tags from {Item.tags} that are present in {.tags} (case insensitive, be careful of localization when comparing case)")
    @figment(effect: "  * {Item.time_updated} = {.time}")
}

extend type Mutation {
    "Remove all tags from an {Item}"
    tags_clear(
        "If known, the {Item.item_id}. At least one of {.item_id} or {.url} must be set to identify the item to act on." item_id: String
        "If known, the {Item.given_url}. At least one of {.item_id} or {.url} must be set to identify the item to act on." url: Url
        "TODO unique_id is a local idea in mobile apps, is this actually sent? Shouldn't be needed..." unique_id: String @_deprecated
    ): Void
    @figment(related_to: "TaggingFeature")
    @figment(auth: "UserAuth")
    @figment(priority: "ASAP")
    @figment(effect: "Look up an {Item} where {Item.id_url} is {.url} or {Item.item_id} is {.item_id} and update:")
    @figment(effect: "  * Clear {Item.tags}")
    @figment(effect: "  * {Item.time_updated} = {.time}")
}

extend type Mutation {
    "Rename a Tag, changing all {Item}'s with that tag to use the new tag name."
    tag_rename(
        "The tag to rename" old_tag: String
        "The new tag name" new_tag: String
    ): Void
    @figment(related_to: "TaggingFeature")
    @figment(auth: "UserAuth")
    @figment(priority: "ASAP")
    @figment(effect: "Clean up and validate {.new_tag} based on rules defined in {Tag.tag}")
    @figment(effect: "Find any {Item} that has {.old_tag} within {Item.tags} (See {Tag.tag} for details on matching tags) and replace {.old_tag} with {.new_tag} and update {Item.time_updated} = {.time}")
    @figment(effect: "If your implementation is not automatically deriving {Tags.tags} or {get.tags}, then also find and rename this tag in those lists.")
}

extend type Mutation {
    "Delete a Tag, removing it from all {Item}'s with that tag."
    tag_delete(
        "The tag to delete" tag: String
    ): Void
    @figment(related_to: "TaggingFeature")
    @figment(auth: "UserAuth")
    @figment(priority: "ASAP")
    @figment(effect: "Find any {Item} that has {.tag} within {Item.tags} (See {Tag.tag} for details on matching tags), remove {.tag} and update {Item.time_updated} = {.time}")
    @figment(effect: "If your implementation is not automatically deriving {Tags.tags} or {get.tags}, then also find and remove this tag from those lists.")
}

"""
An annotation (text highlight) that can be attached to an {Item}

## Notes about {.patch} and {.version}

### Version 2
A patch generated with the [google-diff-match-patch](https://code.google.com/archive/p/google-diff-match-patch/) library, using the following steps:

1. Capture article's full text (including the header containing title, authors, etc.) as `originalText`.
1. Similarly, capture article's full text with highlight markers as `markedUpText`. Use `<pkt_tag_annotation>` and `</pkt_tag_annotation>` for markup.
1. Initialize the library without changing any default values.
1. Use `patch_make` function from the library to create a patch object.
1. Use `patch_toText` function from the library to get a textual representation of the patch.

`patch` field contains the textual representation from the last step.

Note: the library can convert the textual representation back to a patch object with `patch_fromText(text)` function.

#### Example JavaScript implementation
```javascript
getPatch : function() {
	var wholeThing = new Range();
	wholeThing.selectNodeContents(document.body);

	var selection = window.getSelection().getRangeAt(0);

	var before = new Range();
	before.setStart(wholeThing.startContainer, wholeThing.startOffset);
	before.setEnd(selection.startContainer, selection.startOffset);

	var after = new Range();
	after.setStart(selection.endContainer, selection.endOffset);
	after.setEnd(wholeThing.endContainer, wholeThing.endOffset);

	var originalText = before.toString() + selection.toString() + after.toString();
	var modifiedText = before.toString() + "<pkt_tag_annotation>" + selection.toString() + "</pkt_tag_annotation>" + after.toString();

	var dmp = new diff_match_patch();
	return dmp.patch_toText(dmp.patch_make(originalText, modifiedText));
}
```
#### Example generated patch
```diff
@@ -6845,16 +6845,36 @@
 many of
+%3Cpkt_tag_annotation%3E
 you are
@@ -6974,16 +6974,37 @@
 ould you
+%3C/pkt_tag_annotation%3E
  waste y
```

### Version 1
Blank or null. Android launched to Beta without implementing any kind of patches, so the field was left blank or null.

## Limits / Premium
Free users can highlight up to {Account.annotations_per_article_limit} per each {Item}, at which point any further attempts to highlight will show a prompt letting them know they need Pocket Premium to highlight more in this item.

## Javascript
For examples of how to highlight text in the reader:
* See the 4 functions with "annotation" in their name here https://github.com/Pocket/Android/blob/alpha/Pocket/src/main/assets/html/j/articleview-mobile.js#L284
* Highlighting functions in https://github.com/Pocket/Android/blob/alpha/Pocket/src/main/assets/html/j/highlighting.js
* Highlighting css in https://github.com/Pocket/Android/blob/alpha/Pocket/src/main/assets/html/c/highlighting.css
* The diff patch script https://github.com/google/diff-match-patch/wiki/Language:-JavaScript

## Designs

The original Sketch file with assets and specs for Android is linked here:
https://getpocket.atlassian.net/browse/POCKET-8375

2018 Pocket 7 "Lacroix" redesign examples can be seen here:
https://www.figma.com/file/Qqwh8xKl4Gy4YMv6mzw2gCO9/CLEAN?node-id=696%3A907
https://www.figma.com/file/cIDPAbTj5lxDSsBb3TVRMedV/Master-Components?node-id=0%3A1
"""
type Annotation @figment(related_to: "HighlightingFeature") {
    "A unique id for this annotation. Generated at creation time by the client, using a UUID version 4.  (In Java this can be generated with `java.util.UUID.randomUUID().toString()`"
    annotation_id: String @id

    "Id of the {Item} that this Annotation belongs to"
    item_id: String

    "The highlighted text"
    quote: String

    "A patch object providing a representation of where the highlight was applied that's unambiguous and resilient to changes in the article text. See the further explanation the root docs of {Annotation}."
    patch: String

    "Version of the annotation; used to track different patch formats. See the further explanation the root docs of {Annotation}."
    version: Int

    "When this model was added (created)"
    created_at: DateString
}

extend type Mutation {
    "Add a new annotation to an {Item}"
    add_annotation(
        "The new annotation to add to the item." annotation: Annotation
        "The {Annotation.annotation_id} (duplication unfortunately necessary for analytics)" annotation_id: String
        "If known, the {Item.item_id}. At least one of {.item_id} or {.url} must be set to identify the item to act on." item_id: String
        "If known, the {Item.id_url}. At least one of {.item_id} or {.url} must be set to identify the item to act on." url: Url
    ): Void
    @figment(related_to: "HighlightingFeature")
    @figment(auth: "UserAuth")
    @figment(priority: "ASAP")
    @figment(effect: "Look up an {Item} where {Item.id_url} is {.url} or {Item.item_id} is {.item_id} and update:")
    @figment(effect: "  * Add {.annotation} to {Item.annotations}")
    @figment(effect: "  * {Item.time_updated} = {.time}")
    @figment(effect: "Set the {Annotation.created_at} to {.time}")
}

extend type Mutation {
    "Delete an {Annotation} previously added to an {Item}"
    delete_annotation(
        "The {Annotation.annotation_id} of the {Annotation} to remove" annotation_id: String
        "If known, the {Item.item_id}. At least one of {.item_id} or {.url} must be set to identify the item to act on." item_id: String
        "If known, the {Item.id_url}. At least one of {.item_id} or {.url} must be set to identify the item to act on." url: Url
    ): Void
    @figment(related_to: "HighlightingFeature")
    @figment(auth: "UserAuth")
    @figment(priority: "ASAP")
    @figment(effect: "Look up an {Item} where {Item.id_url} is {.url} or {Item.item_id} is {.item_id} and update:")
    @figment(effect: "  * Remove the annotation where {Annotation.annotation_id} = {.annotation_id} from {Item.annotations}")
    @figment(effect: "  * {Item.time_updated} = {.time}")
}

enum ItemStatusKey @figment(related_to: "SearchFeature") {
    "Same as {.unread}"
    queue

    "{Item.status} = {ItemStatus.UNREAD}"
    unread

    "{Item.status} = {ItemStatus.ARCHIVED}"
    archive

    "{Item.status} = {ItemStatus.UNREAD} OR {ItemStatus.ARCHIVED} OR (Item.status = {ItemStatus.NON_LIST_ITEM} && {Item.shares} has at least one where {SharedItem.status} = {SharedItemStatus.UNAPPROVED}"
    anyactive

    "{Item.status} = {ItemStatus.UNREAD} OR {ItemStatus.ARCHIVED}, only currently supported locally, for guest users"
    unread_and_archived

    "{Item.status} = {ItemStatus.UNREAD} OR {ItemStatus.ARCHIVED}"
    all
}

"""
Different ways of sorting lists of {Item}s.
Note: There can be cases where many items will have equal compared values, for example if someone bulk {readd}
several items, they will all end up with the same {Item.time_added}. Though this is not currently implemented cross platform
it is recommended to have equal values have a secondary sorting on {Item.id_url} DESC. This will ensure a consistent sort order
for this corner case. Otherwise those items may appear in a random order when comparing lists on multiple devices.
"""
enum ItemSortKey @figment(related_to: "SearchFeature") {
    "by {Item.time_added} DESC"
    newest

    "by {Item.time_added} ASC"
    oldest

    "by {Item.given_title} ASC"
    title

    "by {Item}'s domain ASC"
    site

    "premium power search. server powered only"
    relevance

    "by {Item.time_updated} DESC"
    updated

    "by most recent of {Item.positions.time_updated} DESC"
    position_updated

    "by {Item.annotations.created_at} DESC"
    annotation

    "by {Item.word_count} ASC (currently only supported locally on Android)"
    shortest

    "by {Item.word_count} DESC (currently only supported locally on Android)"
    longest
}

enum ItemContentType @figment(related_to: "SearchFeature") {
    "The item is an article ({Item.is_article} = true)"
    article

    "The item is a video or contains videos ({Item.has_video} is {Videoness.HAS_VIDEOS} or {Videoness.IS_VIDEO})"
    video

    "The item is an image ({Item.has_image is IS_IMAGE)"
    image

    "The item is an article {Item.is_article} and {Item.word_count} is >= {ListenSettings.item_min_word_count} and {Item.word_count} is {= {ListenSettings.item_max_word_count}"
    listenable
}

"""
Private information about your account. For public info, see {Profile}.
This account info can be obtained through a variety of ways, such as {get}, {getuser}, the various login/signup endpoints such as {Signup.account}
"""
type Account @figment(related_to: "UserAccountFeature") {
    "A unique id (uid) for this user, generated by the server"
    user_id: String @id

    "Alternative email addresses added to an {Account} and its status. This was primarily to allow users to email themselves links and this authorized those email addresses to save links. These are managed by {addAlias} and {deleteAlias}"
    aliases: [EmailAlias]

    "When the account was created. The time is central US"
    birth: DateString

    "The user's primary email address. Required, but there may be some very old accounts without from before it was required. Only one user may have this email address. The user may change this email address."
    email: String

    "Public facing first name, {Profile} may use this. New accounts should provide at least a first or last name."
    first_name: String

    "Your own {Friend} info, for send to friend."
    friend: Friend

    "Public facing last name, {Profile} may use this. New accounts should provide at least a first or last name."
    last_name: String

    "Their current premium subscription status."
    premium_alltime_status: PremiumAllTimeStatus

    "A list of premium features they have enabled."
    premium_features: [PremiumFeature]

    "If they have Premium due to a free trial. Used to for clients to know they should still allow accessing to purchasing Premium so if their trial is expiring they can keep it going."
    premium_on_trial: Boolean

    "If they currently have at least some Premium features. Also see {.premium_alltime_status}, {.premium_on_trial} and {.premium_features} for more detailed info."
    premium_status: Boolean

    "A public facing username, though it isn't prominent. Only one account can share the same name. Modern clients ask for email instead of a username, so many accounts do not have a username until they choose to set one. If a user created an account with social sign on they may have a random generated username starting with a `*`. For the user display this the same as not having a username. TODO why do we create these *usernames, why not do like signing up with email where there is no username set? TODO any restrictions on characters or length?"
    username: String

    "User's own {Profile}"
    profile: Profile

    "How many annotations this user is allowed to add to each article, before the client should block any further additions"
    annotations_per_article_limit: Int
}

"""
See {Account.aliases} for details
"""
type EmailAlias {
    "Whether or not the user has verified they own this email"
    confirmed: Boolean

    email: EmailAddress
}

"""
Get the {Account} model for the authenticated user.
"""
type getuser @figment(related_to: "UserAccountFeature") @figment(auth: "UserAuth") @figment(address: "getuser") {
    "This value should always be set to 9dJDjsla49la"
    hash: String @id

    "The user model for the supplied access token"
    user: Account
}

extend type Mutation {
    """
    Modify the auth'd user's {Account} information.
    Some (TODO document which) fields require the current password to be sent to confirm the changes. Alternatively a google id token can be sent.
    May throw 5102 X-Error if the id_token is invalid
    """
    acctchange(
        "Optional. The new first name, or omit to leave as is" newfirst_name: String
        "Optional. The new username, or omit to leave as is" newusername: String
        "Optional. The new last name, or omit to leave as is" newlast_name: String
        "Optional. The new bio, or omit to leave as is" newbio: String
        "The user's current password" password: Password
        "The user's social sign on id token. See [Auth](\/guide\/auth.md#sso)" id_token: AccessToken
        "Optional. The new password, or omit to leave as is" newpassword: Password
        "Optional. The new email, or omit to leave as is" newemail: String
        "The version of the social sign on token. See [Auth](\/guide\/auth.md#sso)" sso_version: String
        "TODO get more details, but on unlink google requests this is set to \"google\"" source: String
        "True to request that their google account is disconnected from pocket" disconnect_google: Boolean
    ): Void
    @figment(related_to: "UserAccountFeature")
    @figment(auth: "AccountModAuth")
    @figment(address: "acctchange")
    @figment(effect: "apply new values to Account and to Profile")
}

extend type Mutation {
    """
    Upload an avatar for a user's {Account} and {Profile}.
    Note on v3, the response includes a `url` field which states the new avatar url.
    """
    setAvatar(
        "The image file." image: FileField
    ): Void
    @figment(related_to: "UserAccountFeature")
    @figment(auth: "AccountModAuth")
    @figment(address: "setAvatar")
    @figment(effect: "Server creates a new Pocket hosted version of avatar")
    @figment(effect: "Profile and Account avatar fields update")
    @figment(effect: "getProfile should be synced to obtain the new url")
}

extend type Mutation {
    "Add an {EmailAlias} to a user's {Account.aliases}. To remove, use {deleteAlias}"
    addAlias(
        "The email address to add" email: String
    ): Void
    @figment(related_to: "UserAccountFeature")
    @figment(auth: "AccountModAuth")
    @figment(address: "addAlias")
    @figment(effect: "If the email is valid, doesn't already belong to another user, then add to {Account.aliases}")
}

extend type Mutation {
    "Remove an {EmailAlias} to a user's {Account.aliases}. To add, use {addAlias}"
    deleteAlias(
        "The email address to remove" email: String
    ): Void
    @figment(related_to: "UserAccountFeature")
    @figment(auth: "AccountModAuth")
    @figment(address: "deleteAlias")
    @figment(effect: "If this email is already in the user's {Account.aliases}, then remove it")
}

"""
Creates a new GUID.
"""
type guid @figment(related_to: "AuthFeature") @figment(related_to: "UserAccountFeature") @figment(related_to: "AnalyticsFeature") @figment(auth: "NoAuth") @figment(address: "guid") @unique {
    "The new GUID"
    guid: String
}

"""
Pocket sign up with email or username
"""
type Signup @figment(related_to: "AuthFeature") @figment(auth: "LoginAuth") @figment(address: "signup") {
    # Signup fields
    "The email address to create the account for"
    email: EmailAddress @id

    password: Password @id

    "User's entry for the first name field. At least one of the first or last name fields must have a value."
    first_name: String @id

    "User's entry for the last name field. At least one of the first or last name fields must have a value."
    last_name: String @id

    "TODO what is this? Looks like on signup, it is set to `email`"
    source: String @id

    # Analytic fields
    "two letter country code for analytics"
    country: String @id

    "timezone code for analytics"
    timezone: String @id

    "Optional. If on an Android device, this is the referrer from Google Play that gives info on where a user found Pocket's install page"
    play_referrer: String @id

    # 3rd party proxy fields
    "Fields used when a 3rd party uses an official client's auth screens. Optional for normal Pocket use"
    request_token: String @id

    "TODO what is this? Fields used when a 3rd party uses an official client's auth screens. Optional for normal Pocket use"
    use_request_api_id: Boolean @id

    # Device info fields for {.premium_gift} detection
    "Optional, mainly used for checking for premium gifts. The manufacturer of the device the app is running on"
    device_manuf: String @id

    "Optional, mainly used for checking for premium gifts. The model of the device the app is running on"
    device_model: String @id

    "Optional, mainly used for checking for premium gifts. ?"
    device_product: String @id

    "Optional, mainly used for checking for premium gifts. For Android devices, the SID of the device"
    device_sid: String @id

    "Optional, mainly used for checking for premium gifts. For Android devices, the ANDROID_ID of the device"
    device_anid: String @id

    # Response modifier fields
    "Optional `1` to include `tests` in the response.  These kinds of tests have been deprecated."
    getTests: Boolean @deprecated @id

    "Optional `1` to include `account` in the response. This needs a local alias because v3 uses a `account` field in both the request and response but for different values."
    include_account: Boolean @id @figment(v3_alias: "account")

    "1 TODO other values?"
    get_access_token: Boolean @id

    # Fields always returned
    "The access token"
    access_token: AccessToken

    # Fields returned sometimes or if requested
    "True if the user hasn't set a password yet, because they used a social sign on option and if possible, the server requests the client prompts the user for it. See [Social Sign On](/guide/connecting_social.md)"
    prompt_password: Boolean

    "If `getTests` was set in the request, a key:value where the key is the name of the test and the value is an AbTest.  These kinds of tests have been deprecated."
    tests: [AbTest] @map @deprecated

    "If `account` was set in the request, the user's account model"
    account: Account

    "If the user was given premium as a gift, such as through a Samsung Galaxy Gifts promo, this will include a message to show the user"
    premium_gift: PremiumGift
}

"""
Normal Pocket Login for an existing user.
"""
type OAuthAuthorize @figment(related_to: "AuthFeature") @figment(auth: "LoginAuth") @figment(address: "oauth/authorize") {
    # Login fields
    "The username address to log in to. Can use email field alternatively."
    username: String @id

    password: Password @id

    "TODO what is this and are there other values beside `credentials`?"
    grant_type: String @id

    # Analytic fields
    "two letter country code for analytics"
    country: String @id

    "timezone code for analytics"
    timezone: String @id

    "Optional. If on an Android device, this is the referrer from Google Play that gives info on where a user found Pocket's install page"
    play_referrer: String @id

    # 3rd party proxy fields
    "Fields used when a 3rd party uses an official client's auth screens. Optional for normal Pocket use"
    request_token: String @id

    "The URL to be called when the authorization process has been completed. This URL should direct back to your application. See the Platform Specific Notes section for details about setting up custom urls for the redirect_uri on iOS and Android."
    redirect_uri: String @id

    "The consumer key for your application"
    consumer_key: String @id

    "The request token supplied in the code field of the /v3/oauth/request call."
    code: String @id

    "TODO what is this? Fields used when a 3rd party uses an official client's auth screens. Optional for normal Pocket use"
    use_request_api_id: Boolean @id

    # Device info fields for {.premium_gift} detection
    "Optional, mainly used for checking for premium gifts. The manufacturer of the device the app is running on"
    device_manuf: String @id

    "Optional, mainly used for checking for premium gifts. The model of the device the app is running on"
    device_model: String @id

    "Optional, mainly used for checking for premium gifts. ?"
    device_product: String @id

    "Optional, mainly used for checking for premium gifts. For Android devices, the SID of the device"
    device_sid: String @id

    "Optional, mainly used for checking for premium gifts. For Android devices, the ANDROID_ID of the device"
    device_anid: String @id

    # Response modifier fields
    "Optional `1` to include `tests` in the response.  These kinds of tests have been deprecated."
    getTests: Boolean @deprecated @id

    "Optional `1` to include `account` in the response. This needs a local alias because v3 uses a `account` field in both the request and response but for different values."
    include_account: Boolean @id @figment(v3_alias: "account")

    # Fields always returned
    "The access token"
    access_token: AccessToken

    # Fields returned sometimes or if requested
    "True if the user hasn't set a password yet, because they used a social sign on option and if possible, the server requests the client prompts the user for it. See [Social Sign On](/guide/connecting_social.md)"
    prompt_password: Boolean

    "If `getTests` was set in the request, a key:value where the key is the name of the test and the value is an AbTest.  These kinds of tests have been deprecated."
    tests: [AbTest] @map @deprecated

    "If `account` was set in the request, the user's account model"
    account: Account

    "If the user was given premium as a gift, such as through a Samsung Galaxy Gifts promo, this will include a message to show the user"
    premium_gift: PremiumGift
}

"""
v3 errors codes:
5104: (Login Only) No pocket account found for the account the user choose
5108:  Same? TODO find out
5102:  Server could not validate the token.
"""
type OAuthSsoauth @figment(related_to: "AuthFeature") @figment(auth: "LoginAuth") @figment(address: "ssoauth") {
    # Signup/Login fields
    "{SsoAuthMethod.login} for existing users, {SsoAuthMethod.signup} for creating a new account"
    type: SsoAuthMethod @id

    "Type of service used."
    source: SsoAuthService @id

    "Email address of the google account"
    email: EmailAddress @id

    "Required for Google source. Google id token"
    id_token: AccessToken @id

    "Required for Google source. The version of the social sign on token. See [Auth](/guide/auth.md#sso) `3` is for the latest Google Identity API."
    sso_version: String @id

    "Optional. User's first name if known"
    sso_firstname: String @id

    "Optional. User's last name if known"
    sso_lastname: String @id

    "Optional. User's gender if known TODO value typeS?"
    sso_gender: String @id

    "Optional. A url to the User's avatar"
    sso_avatar: String @id

    "Required for Firefox {.source}. TODO document further, but looks like this is hardcoded in."
    client_id: AccessToken @id

    "Required for Firefox {.source}. This is the `state` parameter returned from the firefox auth web flow."
    state: String @id

    "Required for Firefox {.source}. This is the `code` parameter returned from the firefox auth web flow."
    code: String @id

    # Analytic fields
    "two letter country code for analytics"
    country: String @id

    "timezone code for analytics"
    timezone: String @id

    "Optional. If on an Android device, this is the referrer from Google Play that gives info on where a user found Pocket's install page"
    play_referrer: String @id

    # 3rd party proxy fields
    "Fields used when a 3rd party uses an official client's auth screens. Optional for normal Pocket use"
    request_token: String @id

    "TODO what is this? Fields used when a 3rd party uses an official client's auth screens. Optional for normal Pocket use"
    use_request_api_id: Boolean @id

    # Device info fields for {.premium_gift} detection
    "Optional, mainly used for checking for premium gifts. The manufacturer of the device the app is running on"
    device_manuf: String @id

    "Optional, mainly used for checking for premium gifts. The model of the device the app is running on"
    device_model: String @id

    "Optional, mainly used for checking for premium gifts. ?"
    device_product: String @id

    "Optional, mainly used for checking for premium gifts. For Android devices, the SID of the device"
    device_sid: String @id

    "Optional, mainly used for checking for premium gifts. For Android devices, the ANDROID_ID of the device"
    device_anid: String @id

    # Response modifier fields
    "Optional `1` to include `tests` in the response.  These kinds of tests have been deprecated."
    getTests: Boolean @deprecated @id

    "Optional `1` to include `account` in the response. This needs a local alias because v3 uses a `account` field in both the request and response but for different values."
    include_account: Boolean @id @figment(v3_alias: "account")

    # Fields always returned
    "The access token"
    access_token: AccessToken

    # Fields returned sometimes or if requested
    "True if the user hasn't set a password yet, because they used a social sign on option and if possible, the server requests the client prompts the user for it. See [Social Sign On](/guide/connecting_social.md)"
    prompt_password: Boolean

    "If `getTests` was set in the request, a key:value where the key is the name of the test and the value is an AbTest.  These kinds of tests have been deprecated."
    tests: [AbTest] @map @deprecated

    "If `account` was set in the request, the user's account model"
    account: Account

    "If the user was given premium as a gift, such as through a Samsung Galaxy Gifts promo, this will include a message to show the user"
    premium_gift: PremiumGift

    "TODO document when this appears, but the user case is attempting to sign up with an account that already exists. It won't fail but just a heads up this wasn't a signup, it was process as a log in."
    is_existing_user: Boolean
}

enum SsoAuthMethod @figment(related_to: "AuthFeature") {
    login
    signup
}

enum SsoAuthService @figment(related_to: "AuthFeature") {
    google
    firefox
}

"""
Check if an email address is valid for use when signing up for a new Account. This allows apps to check the email field in a sign up form on the fly before the user even clicks the sign up button. If valid, a 200 response will be returned, for all other errors check the X-Error
"""
type validateEmail @figment(related_to: "AuthFeature") @figment(auth: "NoAuth") @figment(address: "validateEmail") {
    "The email to validate"
    email: String @id

    "V4CONVERT the server actually returns the response as a response code, not as a json array, so this doesn't exist as spec'd here."
    valid: Boolean
}

"""
Use to obtain the typical login information when you already have an access token available. Such as when signing in with apple and using v3/apple/android/connect
TODO double check, it is possible some of these fields are actually not supported...
"""
type getAfterLogin @figment(related_to: "AuthFeature") @figment(auth: "UserAuth") @figment(address: "getAfterLogin") {
    # Analytic fields
    "two letter country code for analytics"
    country: String @id

    "timezone code for analytics"
    timezone: String @id

    "Optional. If on an Android device, this is the referrer from Google Play that gives info on where a user found Pocket's install page"
    play_referrer: String @id

    # 3rd party proxy fields
    "Fields used when a 3rd party uses an official client's auth screens. Optional for normal Pocket use"
    request_token: String @id

    "TODO what is this? Fields used when a 3rd party uses an official client's auth screens. Optional for normal Pocket use"
    use_request_api_id: Boolean @id

    # Device info fields for {.premium_gift} detection
    "Optional, mainly used for checking for premium gifts. The manufacturer of the device the app is running on"
    device_manuf: String @id

    "Optional, mainly used for checking for premium gifts. The model of the device the app is running on"
    device_model: String @id

    "Optional, mainly used for checking for premium gifts. ?"
    device_product: String @id

    "Optional, mainly used for checking for premium gifts. For Android devices, the SID of the device"
    device_sid: String @id

    "Optional, mainly used for checking for premium gifts. For Android devices, the ANDROID_ID of the device"
    device_anid: String @id

    # Response modifier fields
    "Optional `1` to include `tests` in the response. These kinds of tests have been deprecated."
    getTests: Boolean @deprecated @id

    "Optional `1` to include `account` in the response. This needs a local alias because v3 uses a `account` field in both the request and response but for different values."
    include_account: Boolean @id @figment(v3_alias: "account")

    "True if the user hasn't set a password yet, because they used a social sign on option and if possible, the server requests the client prompts the user for it. See [Social Sign On](/guide/connecting_social.md)"
    prompt_password: Boolean

    "If `getTests` was set in the request, a key:value where the key is the name of the test and the value is an AbTest.  These kinds of tests have been deprecated."
    tests: [AbTest] @map @deprecated

    "If `account` was set in the request, the user's account model"
    account: Account

    "If the user was given premium as a gift, such as through a Samsung Galaxy Gifts promo, this will include a message to show the user"
    premium_gift: PremiumGift

    "TODO document when this appears, but the user case is attempting to sign up with an account that already exists. It won't fail but just a heads up this wasn't a signup, it was process as a log in."
    is_existing_user: Boolean
}

"""
TODO Document, also see https://getpocket.com/developer/docs/authentication
"""
type OAuthRequestMeta @figment(related_to: "AuthFeature") @figment(auth: "LoginAuth") @figment(address: "oauth/request_meta") {
    request_token: String @id @hash_target

    is_valid: Boolean

    has_access_token: Boolean

    app_name: String

    app_description: String

    app_icon: String

    permission: String
}

extend type Mutation {
    """
    TODO Grants permissions to a token
    TODO document better
    """
    approve_access(
        request_token: String @hash_target
        approve_flag: Boolean
        permission: String
    ): Void @figment(related_to: "UserAccountFeature") @figment(related_to: "AuthFeature") @figment(auth: "AccountModAuth") @figment(address: "oauth/approve_access")
}

"""
If a user has been given Pocket Premium as a gift, typically through a promo such as Samsung Galaxy Gifts, this contains messaging to display to them about it.
For a list of currently active/supported devices check with the backend team. Also see https://github.com/Pocket/Web/blob/master/includes/functions_premium.php#L251 the getPromotionByDeviceModel() function
Some examples, (at the time this was written), are:
* device_manuf="ACER" device_model="A3-A40"
* device_manuf="SAMSUNG" device_model="SM-G930F"
"""
type PremiumGift @figment(related_to: "PocketPremiumFeature") {
    "Label of the button"
    button: String

    "Disclaimer to display"
    disclaimer: String

    "Message to display"
    message: String

    "Title to display"
    title: String

    "The type/reason for the gift. Known values are `samsung` and `acer`. This can be used to display specific branding imagery"
    type: String
}

"""
Loads a web page that displays the Sign In With Apple UI.
If a user successfully logs in, it will redirect to `pocket://apple?access_token=ACCESS_TOKEN` where `ACCESS_TOKEN` is the Pocket access token to use.
App's can then use {getAfterLogin} to get the rest of the login information.
"""
type SignInWithAppleWebFlow @figment(related_to: "AuthFeature") @figment(related_to: "SignInWithAppleFeature") @figment(auth: "GuidAuth") @figment(address: "https://getpocket.com/v3/apple/android/connect") @unique {
    "The web page's content"
    _value: Html @root_value
}

"""
Query the user's list. Also provides access to some unrelated data.

This has a lot of ways to be used. Some example usages:
* Retrieve a user's list of unread items
* Sync data that has changed since the last time your app checked
* Retrieve paged results sorted by the most recent saves
* Retrieve just videos that the user has saved
* Search for a given keyword in item's title and url
* Retrieve additional data like tags, account info, etc.
* And others

This has a lot of options and parameters. If you don't send any, the default behaviour
returns all of the user's unread items sorted by newest
with a basic set of fields on each item.

Note: When using {.changes_since}, items that were deleted will be returned with only their {Item.item_id}. It will have no url fields. You will have to manually look up if you have any items matching that item_id to match it.

The fields below are organized by feature.
"""
type get @figment(related_to: "MyListFeature") @figment(related_to: "SearchFeature") @figment(related_to: "OrganizeFeature") @figment(related_to: "HighlightingFeature") @figment(related_to: "TaggingFeature") @figment(related_to: "PocketPremiumFeature") @figment(related_to: "UserAccountFeature") @figment(related_to: "SendToFriendFeature") @figment(related_to: "ListenFeature") @figment(related_to: "SocialFeature") @figment(related_to: "TwitterFeature") @figment(related_to: "PositionsFeature") @figment(related_to: "RediscoveryFeature") @figment(related_to: "SponsoredContentFeature") @figment(related_to: "NotifyFeature") @figment(related_to: "SiteLoginsFeature") @figment(related_to: "StatsFeaturesFeature") @figment(related_to: "RecentSearchFeature") @figment(auth: "UserAuth") @figment(address: "get") {
    # Fields related to "since", which is a feature that lets you request that only values that have changes since a certain time are returned.
    # This is used for syncing to keep an app up to date and avoids having to reload every single item from the server every time.
    "Limit the response to only things that changed since this time. See each state field for details on how this impacts what it will contain. When syncing, this should be the `since` value from your last {get} call. Can be omitted for all results, but again see each state field's doc for specifics. This needs a local alias because v3 uses a `since` field in both the request and response but for different values."
    changes_since: Timestamp @id @figment(v3_alias: "since")

    "The since to use next time in order to get changes that occurred after this current state"
    since: Timestamp

    # Fields that filter, sort or affect what items are returned in {.list}:
    "Filters {.list} to only items matching a certain status. If not specified, defaults to {ItemStatusKey.all}."
    state: ItemStatusKey @id

    """
    * Filters {.list} to only items matching this search.
    * If unspecified, no effect on {.list}.
    * max length of 100.
    * Free search or offline search matches {Item.given_url}, {Item.resolved_url}, and {Item.title}.
    * Premium search searches a lot more.
    * Supports special operators in premium search as well:

    | Operator      | Example               | Explanation                                                    |
    |---------------|-----------------------|----------------------------------------------------------------|
    | OR            | superman OR batman    | Find items with either search term |
    | AND           | superman AND batman   | Find items that include both search terms |
    | NOT           | superman NOT batman   | Find items that include the first term but not the second term |
    | "sample"      | "superman vs. batman" | Find the exact phrase |
    | +sample       | +batman               | Requires that the search results include this search term |
    | -sample       | -superman             | Requires that the search results do not include this word |
    | #tag          | #coffee               | Find items that have a certain tag |
    | tag:tag       | tag:coffee            | Find items that have a certain tag |
    | #"one tag"    | #"coffee beans"       | Find items that have a certain multi-word tag |
    | tag:"one tag" | tag:"coffee beans"    | Find items that have a certain multi-word tag |
    """
    search: String @id

    "Filters {.list} to only items whose `favorite` field match this value. If true, return only favorited items, if false, only unfavorited items. If unspecified, no effect on {.list}."
    favorite: Boolean @id

    "Filters {.list} to only items whose {.tags} field contains this tag (case insensitive). If unspecified, no effect on {.list}."
    tag: String @id

    "Filters {.list} to only items that match this {ItemContentType}. If unspecified, no effect on {.list}."
    contentType: ItemContentType @id

    "When true, filters {.list} to only items whose {.annotations} field is not empty, when false, filters to items that don't have annotations. If unspecified, no effect on {.list}."
    hasAnnotations: Boolean @id

    "When true, filters {.list} to only items whose {Item.shares} field is has at least one {SharedItem} with a {SharedItem.status} of {SharedItemStatus.ACCEPTED}, when false, filters to items that don't have accepted shares. If unspecified, no effect on {.list}."
    shared: Boolean @deprecated @id

    "Sorts {.list}. When unspecified defaults to {ItemSortKey.newest}."
    sort: ItemSortKey @id

    "Limits {.list} to only a certain number of items. If unspecified, returns all matching items."
    count: Int @id

    "Truncates {.list} to start at a certain index. 0 based. If unspecified, defaults to 0."
    offset: Int @id

    "Limits {.list} to a single item that whose {Item.item_id} matches this value. Only returned if the user has it in their unread items. If unspecified, has no effect on {.list}."
    item: String @id

    # Fields that affect which fields will be declared/included within {Item}s returned in {.list}:
    "`1` to have items in {.list} include the {Item.videos} field. By default that field is not returned."
    videos: Int @id

    "`1` to have items in {.list} include the {Item.images} field. By default that field is not returned."
    images: Int @id

    "`1` to have items in {.list} include the {Item.tags} field. By default that field is not returned. This needs a local alias because v3 uses a `tags` field in both the request and response but for different values."
    include_item_tags: Int @id @figment(v3_alias: "tags")

    "`1` to have items in {.list} include the {Item.positions} field. By default that field is not returned."
    positions: Int @id

    "`1` to have items in {.list} include the {Item.meta} field. By default that field is not returned."
    meta: Int @id

    "`1` to have items in {.list} include the {Item.posts} field. By default that field is not returned."
    posts: Int @id

    "`1` to have items in {.list} include the {Item.authors} field. By default that field is not returned."
    authors: Int @id

    "`1` to have items in {.list} include the {Item.annotations} field. By default that field is not returned."
    annotations: Int @id

    # Fields that enable back filling some number of items to help clients upgrading to new features get some items with those new data fields:
    "`1` to enable a backfill of some number of items with posts."
    forceposts: Int @deprecated @id

    "`1` to enable a backfill of some number of items with tweet attribution."
    forcetweetupgrade: Int @deprecated @id

    "`1` to enable a backfill of some number of items with videos."
    forcevideolength: Int @deprecated @id

    "`1` to enable a backfill of some number of items with annotations."
    forceannotations: Int @deprecated @id

    "`1` to enable a backfill of items (like 50) to help back fill new fields for Pocket 7.0."
    force70upgrade: Int @deprecated @id

    # Fields related to {.list} and the returned items
    "A list of items matching the various parameters supplied"
    list: [Item]
        @derives(reactive: "Item")
        @derives(instructions: "if {.item} is set, limit to a single item, if that user has saved an item with that matching {Item.item_id}")
        @derives(instructions: "if {.since} is set, limit to items whose {Item.time_updated} >= {.since}")
        @derives(instructions: "if {.state} is set, limit to items matching its {ItemStatusKey} rule.")
        @derives(instructions: "if {.search} is set, limit to items that match the search. TODO document what matches a search")
        @derives(instructions: "if {.favorite} is set, limit to items where {Item.favorite} matches this value.")
        @derives(instructions: "if {.tag} is set, limit to items that have this value {Item.tags}")
        @derives(instructions: "if {.contentType} is set, limit to items matching its {ItemContentType} rule.")
        @derives(instructions: "if {.hasAnnotations} is set, limit to only items that have at least one in {Item.annotations}")
        @derives(instructions: "if {.shared} is set and true, limit to items whose {Item.shares} field has at least one {SharedItem} with a {SharedItem.status} of {SharedItemStatus.ACCEPTED}, when false, limit to items that do not have any with {SharedItemStatus.ACCEPTED}. If unspecified, no effect on {.list}.")
        @derives(instructions: "if {.sort} is set, sort by its {ItemSortKey} rule.")
        @derives(instructions: "if {.count} is set, only return at most that number of items items")
        @derives(instructions: "if {.offset} is set, only return items from that index after sorting")
        @derives(instructions: "if {.positions} is set, include the {Item.positions} field in returned items.")
        @derives(instructions: "if {.meta} is set, include the {Item.meta} field in returned items.")
        @derives(instructions: "if {.rediscovery} is set, include the {Item.badge_group_id} field in returned items.")
        @derives(instructions: "if {.include_item_tags} is set, include the {Item.tags} field in returned items.")
        @derives(instructions: "if {.shares} is set, include the {Item.shares} field in returned items.")
        @derives(instructions: "if {.posts} is set, include the {Item.posts} field in returned items.")
        @derives(instructions: "if {.authors} is set, include the {Item.authors} field in returned items.")
        @derives(instructions: "if {.videos} is set, include the {Item.videos} field in returned items.")
        @derives(instructions: "if {.images} is set, include the {Item.images} field in returned items.")
        @derives(instructions: "if {.annotations} is set, include the {Item.annotations} field in returned items.")

    "If returned in a premium search, this contains info about what aspects matched the search, so they can be highlighted to the user"
    search_matches: [SearchMatch] @derives(remap: "list.highlights")

    """
    If returned in a premium search, this contains info about what aspects matched the search, so they can be highlighted to the user
    (Deprecation: Sort Ids are a pattern we should try to avoid in the future, the APIs should just return arrays in the order they are intended. )
    """
    sort_ids: [Int] @deprecated @derives(remap: "list.sort_id")

    "If {.search} is not null this may provide additional search matching details to help give context on what about each item matched a search."
    search_meta: SearchMeta

    # Fields related to Send to Friend features
    "`1` to enable returning Send to Friend related data: The {.friends}, {.recent_friends}, {.auto_complete_emails}, and {.unconfirmed_shares} fields in the response and also have items in {.list} include the {Item.shares} field."
    shares: Int @deprecated @id

    "`1` to force {.auto_complete_emails} to appear regardless of {.changes_since}"
    forcemails: Int @deprecated @id

    "Enabled by the {.shares} flag. Contains any {Friend}s referenced elsewhere by {Friend.friend_id} such as in {SharedItem}s within items in {.list}, `recent_friends` or `auto_complete_emails`."
    friends: [Friend] @deprecated

    "Enabled by the {.shares} flag. {Friend}s most recently shared to via Send to Friend. See {shared_to} for more details. If a {.changes_since} is set, will only be returned if there are changes since that time."
    recent_friends: [Friend] @deprecated @derives(reactive: "Friend") @derives(instructions: "Friends, sorted by {Friend.time_shared} DESC, limited to TODO? amount")

    "Enabled by the `shares` flag. Emails that the user has typed in while sending to friends. See {AcEmail} and {shared_to} for more details. If a `changes_since` is set, will only be returned if there are changes since that time."
    auto_complete_emails: [AcEmail] @deprecated

    "Enabled by the `shares` flag. Deprecated since clients no longer show an Inbox. This should be handled by the server notifying the user. TODO document if needed still."
    unconfirmed_shares: [UnconfirmedShare] @deprecated

    # Fields related to rediscovery features:
    "`1` to enable returning Rediscovery related data: The `carousel`, `highlights` fields in the response and also have items in `list` include the {Item.badge_group_id} field."
    rediscovery: Int @deprecated @id

    "TODO document more precisely, but I believe this forces some kind of backfill of rediscovery data for some set of items."
    forcerediscovery: Int @deprecated @id

    "Enabled by the `rediscovery` flag. Contains any {Group} referenced by {Group.group_id} by {Item.badge_group_id} in `list`. (TODO and likely carousel and highlights?)"
    groups: [Group] @deprecated @derives(reactive: ".list") @derives(instructions: "Any Group whose id is referenced in .list.item.badge_group_id")

    # Fields related to obtaining a list of the users tags:
    "`1` to include the `tags` field in the response."
    taglist: Int @id

    "`1` to force {.tags} to appear regardless of {.changes_since}."
    forcetaglist: Int @id

    "Enabled by `taglist`. All of the users tags. If a `changes_since` is set, will only be returned if there are changes since that time."
    tags: [String] @derives(reactive: "Item.tags") @derives(reactive: "Tag") @derives(instructions: "if forcetaglist=1, always return") @derives(instructions: "else if taglist=1 and the list of tags has changed since, return") @derives(instructions: "else do not return")

    # Fields related to spocs (sponsored content):
    # Deprecated. Q1 2020 we switched to Adzerk/Kevel.
    "`1` to include the {.placements} field in the response."
    sposts: Int @deprecated @id

    "Enabled by {.sposts}. Spocs to show the user in My List."
    placements: [FeedItem] @deprecated

    # Fields related to obtaining the user's account information:
    "`1` to include the {.account} field in the response. This needs a local alias because v3 uses a `account` field in both the request and response but for different values."
    include_account: Int @id @figment(v3_alias: "account")

    "`1` to force {.account} to appear regardless of {.changes_since}."
    forceaccount: Int @id

    "Enabled by {.include_account}. The latest account info. If a {.changes_since} is set, will only be returned if there are changes since that time."
    account: Account @derives(instructions: "if forceAccount=1, always return") @derives(instructions: "else if since, only return if the account has changed since") @derives(instructions: "else do not return")

    # Fields related to finding out if there are new notifications available:
    "`1` to include {.notificationStatus} in the response. This needs a local alias because v3 uses a `notificationstatus` field in both the request and response but for different values."
    include_notification_status: Int @id @figment(v3_alias: "notificationstatus")

    "Enabled by {.include_notification_status}. 1 if there are new notifications since {.changes_since}. See {getNotifications}"
    notificationStatus: Int @derives(instructions: "if notificationstatus=true and getNotifications has changed since, return 1") @derives(instructions: "else do not return")

    # Fields related to premium features:
    "`1` to enable returning Premium related data: The {.recent_searches} field in the response"
    premium: Int @id

    "`1` to force {.recent_searches} to appear regardless of {.changes_since}"
    forcepremium: Int @id

    "Enabled by {.premium}. The users most recent searches. Only appears for accounts that have premium search. If a {.changes_since} is set, will only be returned if there are changes since that time."
    recent_searches: [SearchQuery] @derives(reactive: "Account.premium_features") @derives(reactive: "SearchQuery") @derives(instructions: "if Account.premium_features does not include PremiumFeature.SEARCH do not return") @derives(instructions: "if .forcepremium=1, always return") @derives(instructions: "if .premium=1 return only if has changed since") @derives(instructions: "returns the TODO? latest SearchQuery ordered by SearchQuery.time DESC")

    # Fields related to the site login feature:
    "`1` to include {.lastLoginRuleCheck} in the response."
    loginRuleCheck: Int @id @deprecated

    "Enabled by {.loginRuleCheck}. A version number of site login templates. If it is higher than the version you last downloaded, then there are updates to go download from {loginlist}. TODO does {.changes_since} impact this value?"
    lastLoginRuleCheck: Int @deprecated

    # Fields related to connected social accounts:
    "`1` to include {.connectedAccounts} in the response. This needs a local alias because v3 uses a `connectedaccounts` field in both the request and response but for different values."
    include_connected_accounts: Int @id @figment(v3_alias: "connectedaccounts")

    "`1` to force {.connectedAccounts} to appear regardless of {.changes_since}."
    forceconnectedaccounts: Int @id

    "Enabled by {.include_connected_accounts}. {PostService} that have valid tokens available for use in {share_post} actions. Only appears if `connectedAccounts` requested. If a {.changes_since} is set, will only be returned if there are changes since that time."
    connectedAccounts: [PostService] @derives(instructions: "if forceconnectedaccounts=1, always return") @derives(instructions: "else if connectedAccounts=1, only return if changed since")

    # Fields related to list counts (unreleased):
    "true to include {.counts} in the response. Note: This only made it into alpha, may require further QA to verify it is fully functional."
    listCount : Boolean @id

    "`1` to force {.counts} to appear regardless of {.changes_since}"
    forceListCount : Boolean @id

    "Enabled by {.listCount}. Current counts of common filters in Pocket. This was never released to production."
    counts : ListCounts @deprecated

    # Fields related to settings:
    "`1` to include {.clientSettings} regardless of the {.changes_since} value."
    forcesettings: Int @id

    "`1` to include the {ClientSettings.listen} field within {.clientSettings} if it is returned."
    listen: Boolean @id

    "Settings for client-side features. Always appears if there are changes since {.changes_since}. TODO is this true?"
    clientSettings: ClientSettings

    "The maximum number of actions that should be sent to v3/send. If there are more actions to send, do it in several requests instead of a huge one. This always appears."
    maxActions: Int

    # Fields related to {UserMessage}:
    "Requests {.userMessage} if there are any messages to show since this time."
    since_m: Timestamp @id

    "Only returned if {.since_m} is set and there is a message to display."
    userMessage: UserMessage

    # Analytics fields:
    "For analytics, a note of what kind of search this is from."
    cxt_search_type: CxtSearchType @deprecated @id

    # Misc:
    filters: [ItemFilterKey] @id
}

"""
Contains additional information about what aspects of a search matched items.
"""
type SearchMeta {
    "used for paging to know if there are more results to fetch by increasing the offset"
    has_more: Boolean
}

type SearchItem @figment(related_to: "SearchFeature") {
    item: Item

    "(Deprecation: Sort Ids are a pattern we should try to avoid in the future, the APIs should just return arrays in the order they are intended. This should also be remapped to the parent query, it shouldn't be here in the thing itself.)"
    sort_id: Int @deprecated

    matches: SearchMatch
}

"""
Information and preformatting about what aspects of an {Item} matched a search query.
"""
type SearchMatch @figment(related_to: "SearchFeature") {
    "If not null, then the content matched the search. This will contain a block of text related to the search with the matching segments wrapped in some simple html like `<b></b>` or `<em></em>`"
    fullText: HtmlString

    "If not null, then this will be the tag that matched the search. At this time, only one tag will ever be returned, this will not be a list."
    tags: HtmlString

    "If not null, then the title matched the search. The full title will be included and the matching segments will be wrapped in some simple html like `<b></b>` or `<em></em>`"
    title: HtmlString

    "If not null, then the url matched the search. The full url will be included and the matching segments will be wrapped in some simple html like `<b></b>` or `<em></em>` **!TODO verify this**"
    url: HtmlString

    "This was a typo, v3 actually returns it as `fullText`, so this field wasn't matching anything in the response and was always undefined."
    full_text: HtmlString @deprecated
}

"""
Settings for client-side features
"""
type ClientSettings @unique {
    "Settings for the Listen feature"
    listen: ListenSettings
}

"""
Settings for the Listen feature
"""
type ListenSettings @figment(related_to: "ListenFeature") @unique {
    "Maximum word count of items allowed to be included in Listen playlist. Defaults to 24000 if unknown."
    item_max_word_count: Int

    "Minimum word count of items allowed to be included in Listen playlist. Defaults to 0 if unknown."
    item_min_word_count: Int

    "List of two character language codes supported by Listen"
    item_supported_languages: [String]
}

"""
Retrieve a user's list in batches instead of a large {get} call.
Since the user may have thousands of saved items, this can be used when you need to download the entire list.

## Deprecation:
The purpose of this endpoint was to make sure the large initial download of the list was done in batches.
However, you can accomplish the same thing using {get}:
1. Make a call to {get} with {get.count} = 25 and {get.offset} = 0, and include any flags needed to get meta data like account, tags, friends, etc.
2. Then repeating until {get} returns less than you asked or 0 items, make a call with {get.count} = 250 and increase {get.offset} each time (25, then 275, 525 etc.). In these additional calls you can exlcude extra flags like the tag list, since you got them in the first call.

## Usage
1. Make the first fetch call as just `fetch?shares=1`
2. Then the `list` field will contain the first batch of items.
3. Then if the first fetch's `remaining_chunks` is > 0, iterate from 1 to `remaining_chunks` as `chunk`
and for each chunk fire a fetch call with `shares`, `updatedBefore`, `offset`, `count`, and `chunk`. See the docs on each of those fields for what values to use.
4. Then save the items returned from all of those calls as well.

TODO an example of values and requests could be useful to help clarify this.

After processing all of the chunks, you will have all of the user's saved, unarchived items.
For clients using fetch, they likely will want to finish the fetching process with a {get} call as well.
See the {get} docs for more details.

Note: The v3 API will return at most 5000 items through fetching. If the user has more than 5000 items saved, they will only be able to get the latest 5000.
"""
type fetch @_deprecated @figment(related_to: "MyListFeature") @figment(auth: "UserAuth") @figment(address: "fetch") {
    "The `since` value from the first fetch"
    updatedBefore: Timestamp @id

    "For the first fetch, this should be unset. For follow up fetches this should be `first.passthrough.firstChunkSize + first.passthrough.fetchChunkSize * (chunk-1)` where `first` is the result of the first fetch."
    offset: Int @id

    "For the first fetch, should be unset, for all other fetches, this should be `first.passthrough.fetchChunkSize` where `first` is the result of the first fetch."
    count: Int @id

    "For the first fetch, should be unset, for all other fetches, this should increment from 1 to as many additional chunks needed. See `remaining_chunks`."
    chunk: Int @id

    "Same as {get}.shares, includes shared items in the item data."
    shares: Boolean @id

    "Same as {get}.annotations, includes annotations in the item data."
    annotations: Boolean @id

    "Contains information about how to batch the fetches"
    passthrough: FetchPassthrough

    "Returned in the first fetch, the total number of items to retrieve"
    total: Int

    "Same as {get}.maxActions"
    maxActions: Int

    "For the first fetch, this returns a value that should be used for `updatedBefore` on all fetch calls after the first one. Also use it as the {get}.since on the first get call after fetching."
    since: Timestamp

    "The items in this chunk"
    list: [Item]

    "Only appears if `shares` requested, friends referenced in shares within the items in `list`."
    friends: [Friend]

    "Any groups referenced by items in `list`"
    groups: [Group]

    "Same as {get.auto_complete_emails}"
    auto_complete_emails: [AcEmail]

    "Same as {get.recent_friends}"
    recent_friends: [Friend]

    "How many items after the first chunk are remaining to fetch"
    remaining_items: Int
        @derives(reactive: ".total")
        @derives(reactive: ".passthrough")
        @derives(instructions: "Not returned by server, only specified here to clarify how clients should calculate this")
        @derives(instructions: "Only calculate this if it is the first fetch call ({.chunk} is undeclared)")
        @derives(instructions: "Then calculate this by doing : {.total} - {.passthrough.firstChunkSize}")
        @derives(instructions: "Note: If {.total} is null, then the list is empty, return 0")

    "How many chunks"
    remaining_chunks: Int
        @derives(reactive: ".remaining_items")
        @derives(reactive: ".passthrough")
        @derives(instructions: "Not returned by server, only specified here to clarify how clients should calculate this")
        @derives(instructions: "Only calculate this if it is the first fetch call ({.chunk} is undeclared)")
        @derives(instructions: "If {.remaining_items} or {.passthrough.fetchChunkSize} is 0, then this is also 0, otherwise")
        @derives(instructions: "calculate this by doing : {.remaining_items} / {.passthrough.fetchChunkSize} and rounding up.")
}

"""
Part of {fetch}
"""
type FetchPassthrough {
    "How many items were returned in the first fetch."
    firstChunkSize: Int

    "How many items you should request per chunk for any remaining chunks. See {fetch}.count"
    fetchChunkSize: Int
}

"""
Query a specific {Item}. The item must be in the user's list.
"""
type getItem @figment(related_to: "SearchFeature") @figment(auth: "UserAuth") @figment(address: "getItem") {
    "The `item_id` of the {Item} to retrieve. The item must be in the user's list"
    item_id: String @id

    "An object with the item_id as the key and the queried item as the value, or empty if there was no item found or if the user does not have this item in their list"
    item: [Item] @map @derives(instructions: "A map of item_id -> Item where Item{item_id=.item_id} and the user has saved it")

    "Any Group whose id is referenced in .list.item.badge_group_id"
    groups: [Group] @derives(reactive: ".item") @derives(instructions: "Any Group whose id is referenced in .list.item.badge_group_id")
}

"""
Query a specific {Item} by passing in the short code from a pocket.co URL. For example, for the pocket.co URL: pocket.co/xMAtyF - the short code is: xMAtyF.
"""
type getItemForShortCode @_deprecated @figment(related_to: "UrlShorteningFeature") @figment(related_to: "SearchFeature") @figment(auth: "UserOptionalAuth") @figment(address: "getItemForShortCode") {
    "Version of the API to use. Set to 1"
    version: String @id

    "The `short code` from the pocket.co URL that you want to retrieve the {Item} for."
    short_code: String @id

    "If user auth is provided, the user's item meta will also be included, otherwise just basic item info"
    item: Item
}

extend type DomainMetadata {
    "Url for the greyscale logo image"
    greyscale_logo: Url @figment(client_api_alias: "logoGreyscale")
}

extend type Author {
    "Unique id for that Author. Likely numerical, but should be treated as String for long term compatability"
    author_id: Int @id
}

extend type Video @figment(related_to: "VideosFeature") {
    "The id of the video within Article View. {articleView.article} will have placeholders of <div id='RIL_VID_X' /> where X is this id. Apps can download those images as needed and populate them in their article view."
    video_id: Int @figment(client_api_alias: "videoId")
}

extend enum VideoType @figment(related_to: "VideosFeature")
@enum_value(name: "YOUTUBE", value: "1")
@enum_value(name: "VIMEO_LINK", value: "2")
@enum_value(name: "VIMEO_MOOGALOOP", value: "3")
@enum_value(name: "VIMEO_IFRAME", value: "4")
@enum_value(name: "HTML5", value: "5")
@enum_value(name: "FLASH", value: "6")
@enum_value(name: "IFRAME", value: "7")
@enum_value(name: "BRIGHTCOVE", value: "8")

extend enum Videoness @figment(related_to: "VideosFeature")
@enum_value(name: "NO_VIDEOS", value: "0")
@enum_value(name: "HAS_VIDEOS", value: "1")
@enum_value(name: "IS_VIDEO", value: "2")

extend type Image @figment(related_to: "ImagesFeature") {
    "The id for placing within an Article View. {articleView.article} will have placeholders of <div id='RIL_IMG_X' /> where X is this id. Apps can download those images as needed and populate them in their article view."
    image_id: Int @figment(client_api_alias: "imageId")
}

extend enum Imageness @figment(related_to: "ImagesFeature")
@enum_value(name: "NO_IMAGES", value: "0")
@enum_value(name: "HAS_IMAGES", value: "1")
@enum_value(name: "IS_IMAGE", value: "2")

"""
Get available audio files for playing an {Item} in Listen
"""
type getItemAudio @figment(related_to: "ListenFeature") @figment(auth: "UserAuth") @figment(address: "getItemAudio") {
    "Version of the API to use. Set to 2"
    version: String @id

    "The `item_id` of the {Item} to get the audio url for."
    itemId: String @id

    "Users locale to support different voice accents."
    accent_locale: String @id

    "The available audio files."
    files: [ItemAudioFile]
}

"""
An audio file for playing an {Item} in Listen
"""
type ItemAudioFile {
    "File format used by clients to filter out unsupported files."
    format: String

    "URL to play the audio from for the given {Item}."
    url: Url

    "Is this file available or not."
    status: AudioFileStatus

    "File duration in seconds."
    duration: Int
}

enum AudioFileStatus @figment(related_to: "ListenFeature") {
    "Ready to download or stream"
    available

    "Server is working on making this file available"
    processing
}

"""
Get a list of paywalled sites that a client app can easily setup for offline downloading on behalf of a user.
TODO should ask the backend to have this return the {get.lastLoginRuleCheck} as a state field so we can match the response with that id.
"""
type loginlist @_deprecated @figment(related_to: "SiteLoginsFeature") @figment(auth: "NoAuth") @figment(address: "loginlist") {
    "Version of the API to use. Set to 1"
    hash: String @id

    "A mapping of domains that share a template. The `alias` domain should share the same template as the template for `domain` found in the `list`."
    aliases: [String] @map

    "A list of all available templates."
    list: [PayWallTemplate]

    "A client local only list of hosts that the user has logged in to and cookies are setup for use."
    logged_in: [String] @local
}

"""
Details needed to implement a site login / subscription template.
TODO looks like there was a field called 'forceLogins' is that used at all? If so, where and what is it
"""
type PayWallTemplate @_deprecated @figment(related_to: "SiteLoginsFeature") {
    "The domain (ex “arstechnica.com”)"
    host: String @id

    "The display name of the site (Ex: “Ars Technica”)"
    name: String

    "The URL to submit the form to"
    target: String

    "The display name of the username field (ex “Username” or “Email”)"
    userLabel: String

    "The form field name of the username field"
    user: String

    "The form field name of the password field"
    pass: String

    "The form field name of the (generally hidden) value that indicates where to send the user after logging in. (Some sites need this for the form to work)"
    url: String

    "Extra form data to add to the POST/GET. These are values that do not change but are often required for the form to work (ex “&autologin=on&submitButtonName=Login”). Important: Always start this with a ‘&'"
    suffix: String

    "`GET` or `POST` The http method to use to submit the request"
    method: String

    "The page to find the tokens in"
    token_url: String

    "If required, any tokens that will need to be obtained before making the request. The key is the name of the token, the value of the map is regex used to obtain the value to assign to that token"
    tokens: [String] @map

    "A Regex that if matched means you were logged in (ex '\"/myaccount/logout\"' - A logout link now appears in the markup)"
    checkPage: String

    "Used when verifying via a cookie. The cookie to look for"
    checkVar: String

    "Used when verifying via a cookie. This is a regex that must be matched on the value of the cookie var"
    checkVal: String

    "True for clients not to attempt to extend the lifespan of the cookies"
    skipExtend: Boolean
}

"""
A system that allows Pocket to send a specific user or group of users messages that appear after syncing inside of any of Pocket's native applications.
Originally spec'd here https://docs.google.com/document/d/1gAv_TGHMEtK4E3KB9VtAhaHZqqyyV6-e1EKrq7MXDv8/edit#heading=h.dy9xthri1g9d Deprecated. This framework may work, but it hasn't been tested in a long time and we have the notifications framework now which can likely replace this. This was created as a way to send important messages to the user in app, but email and notifications can be used in most cases. If this is used again in the future, extensive testing should be done.
Note: This was designed before we had the {Notification} framework. This could potentially be merged with or replaced by the notification framework if the notifications added some new types or {Notification.display_locs}
"""
type UserMessage @figment(related_to: "NotifyFeature") {
    "a Unique identifier for the message"
    message_id: String

    "An identifier for what type of UI to display the message in."
    message_ui_id: UserMessageUi

    "The already-localized title to display (this can be blank if the UI does not support a title)"
    title: String

    "The already-localized message to display (this can be blank if the UI does not support a message)"
    message: String

    "Buttons/actions to display that they can take. The first button is always the “cancel” button in the UI. Additional buttons may be required depending on the UI selected."
    buttons: [UserMessageButton]
}

type UserMessageButton {
    "The label is the already-localized title to show on the button"
    label: String

    "What to do when clicked"
    action: UserMessageAction
}

type UserMessageAction {
    "(required) A key name for the action"
    id: UserMessageActionType

    "(optional) An object additional information needed for the action"
    meta: UserMessageActionMeta
}

enum UserMessageActionType {
    "Dismiss the message"
    close

    "Launch the Premium renew flow"
    renew

    "Launch the Premium page"
    premium

    "Launch a browser to the url found in {UserMessageAction.meta.url}"
    browser
}

type UserMessageActionMeta {
    "A url to open when the {UserMessageButton} is clicked"
    url: Url
}

enum UserMessageUi {
    "Display the message using a pop up dialog that was custom designed for this. It should have two buttons."
    MESSAGE_UI_CUSTOM_POPUP @figment(enum_value: "1")

    "For the web app, displays as a banner at the top of the app."
    MESSAGE_UI_WEB_STATUS_BAR @figment(enum_value: "2")
}

enum UserMessageResult {
    SHOWN @figment(enum_value: "1")

    UNKNOWN_UI_FORMAT @figment(enum_value: "10")

    ALREADY_SHOWN @figment(enum_value: "11")

    USER_NOT_PRESENT @figment(enum_value: "20")
}

"""
A notification for the user.
"""
type Notification @figment(related_to: "NotifyFeature") {
    "A unique id for this notification"
    user_notification_id: String @id

    "If the notification it 'clicked' what should be opened"
    destination_url: String

    "A list of where this notification can be displayed."
    display_locs: [NotificationDisplayLoc]

    "Optional. If there was a related {Item} this will contain the bare bones info about it"
    item: NotificationItem

    "Things can be done"
    notification_actions: [NotificationButton]

    "The title of the notification."
    notification_title: String @local

    "The body text of the notification"
    notification_text: LinkedText

    "A Url for an image icon to display"
    notification_icon_image: Url @local

    "A Url for an full screen image to display"
    notification_full_image: Url @local

    "Optional. If there was a related post"
    post: Post

    "Optional. If there is a person involved, such as the person that posted something a notification is about"
    profile: Profile

    "When this notification was created, typically related to the time the action that triggered it occurred"
    time_added: Timestamp

    updated_at: Timestamp

    "2 means it has been viewed."
    status: Int

    "Where does the [Notification] come from?"
    source: NotificationSource @local
}

enum NotificationDisplayLoc @figment(related_to: "NotifyFeature") {
    "enables it to be shown in the notification screen within the Pocket app"
    in_app @figment(name: "in-app")

    "means it is ok to show in the device's OS/system notification feed"
    device
}

"""
Contents of the `notification_action` object. Part of {Notification}
"""
type NotificationButton {
    "The name of the action that should occur when this action is taken. Currently supported {follow_user} (or \"follow\" as an alias to that one), {share_added}"
    action_name: String

    "Some additional values depending on what {.action_name} this is."
    data: NotificationButtonData

    "Whether or not to show this action. `1` to show it"
    enabled: Boolean

    "The display label of the action after it has been performed"
    taken_text: String

    "The display label of the action"
    text: String

    "The time the action was taken"
    taken_time: Timestamp @local
}

"""
 Part of {Notification}
"""
type NotificationButtonData {
    "For when {NotificationButton.action_name} is {follow_user} or \"follow\""
    uid: String

    "For item based actions, like {share_added}"
    given_url: Url

    "For share item actions, like {share_added}"
    share_id: String
}

"""
 Part of {Notification}
"""
type NotificationItem {
    "The domain of the item involved"
    domain: String

    "The title of the item involved"
    title: String
}

enum NotificationSource {
    "Amazon Pinpoint service"
    pinpoint
}

"""
Get a specific message to display to the user. This was originally added as a way to display a pre-login message to users eligible for Samsung Galaxy Gifts.
See {PremiumGift} for more details
"""
type getMessage @_deprecated @figment(related_to: "PocketPremiumFeature") @figment(related_to: "NotifyFeature") @figment(auth: "UserAuth") @figment(address: "getMessage") {
    "The model of the device the app is running on"
    device_model: String @id

    "? on Android this is the android.os.Build.PRODUCT value"
    device_product: String @id

    "For Android devices, the ANDROID_ID of the device"
    device_anid: String @id

    "The message to retrieve."
    messageType: GetMessageType @id

    "For Android devices, the SID of the device"
    device_sid: String @id

    "The manufacturer of the device the app is running on"
    device_manuf: String @id

    "The message to show or null if nothing to show"
    message: String
}

enum GetMessageType @figment(related_to: "NotifyFeature") {
    "A message to show at the top of the login screen"
    splash
}

"""
Get the most recent {Notification}s for the auth'd user.
"""
type getNotifications @figment(related_to: "NotifyFeature") @figment(auth: "UserAuth") @figment(address: "getNotifications") {
    "Version of the API to use. Set to 1"
    version: String @id

    "A list of {Notification}s"
    notifications: [Notification]
}

"""
Returns a pocket.co, short url for any url with analytics tied to the auth'd user. Typically used for creating a url to be shared outside of Pocket that can provide insights on engagement with the shared link.
"""
type shorten @figment(related_to: "SharingFeature") @figment(related_to: "UrlShorteningFeature") @figment(auth: "UserAuth") @figment(address: "shorten") {
    "The url to shorten"
    url: String @id

    "The service/app/method the link will be shared to such as `twitter`"
    service: String @id

    "The shortened url"
    shortUrl: String
}

"""
An {Item} shared to a user via Send to Friend
"""
type SharedItem @_deprecated @figment(related_to: "SendToFriendFeature") {
    "A unique id for this share"
    share_id: String @id

    "Optional. If they added a comment"
    comment: String

    "The `friend_id` of the {Friend} that shared it"
    from_friend_id: String

    "The friend that shared it to you."
    friend: Friend @local
        @derives(reactive: ".from_friend_id") @derives(reactive: "Friends")
        @derives(instructions: "Where {Friend.friend_id} is {.from_friend_id}")

    "The `item_id` of the {Item} that was shared"
    item_id: String

    "Optional. If they quoted part of it"
    quote: String

    "The state of this share."
    status: SharedItemStatus

    time_shared: Timestamp

    time_ignored: Timestamp
}

enum SharedItemStatus @_deprecated @figment(related_to: "SendToFriendFeature") {
    "unapproved. No action taken on it yet"
    UNAPPROVED @figment(enum_value: "0")

    "User has approved/accepted this share"
    ACCEPTED @figment(enum_value: "1")

    "User has ignored/discarded this share"
    DISCARDED @figment(enum_value: "2")

    "Same as 2 but the user also wants to block this user. Blocking was a potential feature, not ever implemented"
    BLOCKED @figment(enum_value: "3")
}

extend type Mutation {
    """
    Creates and sends a {SharedItem} directly and privately to someone. This feature is called Send to Friend.
    Originally spec'd here https://docs.google.com/document/d/1-PrbRQJWakVp11PdT8QTbb39SjrnhXpb1sdKWcF3R0w
    Also see {share_added} and {share_ignored}
    """
    shared_to(
        "If known, the {Item.item_id} of the item to share. At least one of {.item_id} or {.url} must be set to identify the item to act on." item_id: String
        "If known, the {Item.given_url} of the item to share. At least one of {.item_id} or {.url} must be set to identify the item to act on." url: Url
        "A list of recipients to send this to." to: [StfRecipient]
        "Optional. A title to use when sharing. If not included it will use the user's {Item.given_title}." title: String
        "Optional. A user comment to display when sharing." comment: String
        "Optional. A user selection to display when sharing." quote: String
    ): SharedToResult
    @deprecated
    @figment(related_to: "SendToFriendFeature")
    @figment(auth: "UserAuth")
    @figment(priority: "ASAP")
    @figment(effect: "Clients:")
    @figment(effect: "Iterate through recipients in {.to}")
    @figment(effect: "For ones where {StfRecipient.friend_id} is > 0, find the {Friend} by matching {StfRecipient.friend_id} and {Friend.friend_id} and update its {Friend.time_shared} to {.time}. Also move that {Friend} to the top of {RecentFriends.recent_friends}.")
    @figment(effect: "For ones where {StfRecipient.friend_id} is null or 0, if it does not already exist, find or create a {AcEmail} with the email from {StfRecipient.email}. update its {AcEmail.time_shared} to {.time} and if needed add it to {AutoCompleteEmails}.")
    @figment(effect: "")
    @figment(effect: "Note: Originally clients would create a local only {Friend} using a Friend.local_friend_id but this was fairly complex to resolve later, since the client had to listen to the response of v3\/send to get the {Friend.friend_id} for this friend and set it. This got complex handling all of the possible cases for when an email might resolve to a {Friend} now or in the future. However, after looking at it again, it seems clients can get by without creating a local only friend as long as they also source their recently shared to UI from a combination of {RecentFriends} and {AutoCompleteEmails}. WIP clean up this explanation")
    @figment(effect: "")
    @figment(effect: "Backend:")
    @figment(effect: "There are several cases to handle:")
    @figment(effect: "")
    @figment(effect: "1. Sending to a known Friend, (when {StfRecipient.friend_id} is > 0)")
    @figment(effect: "")
    @figment(effect: "TODO flush out more, but depending on the recipients account settings they may receive an email and\/or {Notification}.")
    @figment(effect: "")
    @figment(effect: "What the sending client sees after syncing:")
    @figment(effect: "* This friend will show up higher in {get.recent_friends}")
    @figment(effect: "")
    @figment(effect: "What the receiving client sees after syncing:")
    @figment(effect: "* They will see a {Notification} in their Activity tab via {getNotifications} where they can accept the share.")
    @figment(effect: "* TODO check... does this item show up in {get.list} ?")
    @figment(effect: "")
    @figment(effect: "2. Sending to an email address that does not match any existing Pocket account")
    @figment(effect: "")
    @figment(effect: "TODO flush out more, but it sends an email to that address telling them that this person shared this item with them and has a link to get pocket if they want.")
    @figment(effect: "")
    @figment(effect: "What the sending client sees after syncing:")
    @figment(effect: "* This email will show up in {get.auto_complete_emails} with a friend_id of 0, since it is not a confirmed pocket user.")
    @figment(effect: "")
    @figment(effect: "What the receiving client sees after syncing:")
    @figment(effect: "* N\/A since they do not have Pocket")
    @figment(effect: "")
    @figment(effect: "3. Sending to an email address that is associated with a Pocket account, but they have not confirmed that email yet")
    @figment(effect: "")
    @figment(effect: "TODO flush out more, but since they have not confirmed they own this email address, they should not be able to see what item was shared.")
    @figment(effect: "This prevents someone from signing up with someone elses email address and receiving shares meant for them.")
    @figment(effect: "Instead they receive an email and a {Notification} saying there are shares but they might confirm their email before they can see what they are.")
    @figment(effect: "")
    @figment(effect: "What the sending client sees after syncing:")
    @figment(effect: "")
    @figment(effect: "What the receiving client sees after syncing:")
    @figment(effect: "* They will see a {Notification} in their Activity tab via {getNotifications} about shares waiting, but they need to confirm their email.")
    @figment(effect: "* {get.unconfirmed_shares} will also appear")
    @figment(effect: "")
    @figment(effect: "4. Sending to an email address that is associated with a Pocket account, and the email is confirmed.")
    @figment(effect: "")
    @figment(effect: "TODO flush out more, but depending on the recipients account settings they may receive an email and\/or {Notification}.")
    @figment(effect: "")
    @figment(effect: "What the sending client sees after syncing:")
    @figment(effect: "* This friend will show up higher in {get.recent_friends}")
    @figment(effect: "* This friend and email will show up in {get.auto_complete_emails}")
    @figment(effect: "")
    @figment(effect: "What the receiving client sees after syncing:")
    @figment(effect: "* They will see a {Notification} in their Activity tab via {getNotifications} where they can accept the share.")
    @figment(effect: "* TODO check... does this item show up in {get.list} ?")
}

"""
The shape of what v3/send returns for a {shared_to} action
"""
type SharedToResult @_deprecated @figment(related_to: "SendToFriendFeature") {
    "Friend models for those that were shared to in the action"
    to_friends: [Friend]

    "The item that was shared"
    item: Item
}

extend type Mutation {
    """
    Ignore/decline/reject a {SharedItem} from send to friend
    This isn't used in modern apps which are using {getNotifications} instead of the old "Inbox" via getPendingShares
    """
    share_ignored(
        "If known, the {Item.item_id}. At least one of {.item_id} or {.url} must be set to identify the item to act on." item_id: String
        "If known, the {Item.given_url}. At least one of {.item_id} or {.url} must be set to identify the item to act on." url: Url
        "The id of the {SharedItem}" share_id: String
    ): Void
    @deprecated
    @figment(related_to: "SendToFriendFeature")
    @figment(auth: "UserAuth")
    @figment(priority: "ASAP")
    @figment(effect: "Find the {SharedItem} where {SharedItem.share_id} is {.share_id} and then:")
    @figment(effect: "  * set {SharedItem.status} to {SharedItemStatus.DISCARDED}")
    @figment(effect: "  * set {SharedItem.time_ignored} = {.time}")
}

extend type Mutation {
    """
    Accept and save a {SharedItem} from send to friend
    """
    share_added(
        "If known, the {Item.item_id}. At least one of {.item_id} or {.url} must be set to identify the item to act on." item_id: String
        "If known, the {Item.given_url}. At least one of {.item_id} or {.url} must be set to identify the item to act on." url: Url
        "The id of the {SharedItem}" share_id: String
    ): Item
    @deprecated
    @figment(related_to: "SendToFriendFeature")
    @figment(auth: "UserAuth")
    @figment(priority: "ASAP")
    @figment(effect: "Find the {SharedItem} where {SharedItem.share_id} is {.share_id} and then:")
    @figment(effect: "  * set {SharedItem.status} to {SharedItemStatus.ACCEPTED}")
    @figment(effect: "Do the same as an {add} action with the same {.item_id} and {.url}")
}

"""
How the Send to Friend feature represents a person that shared an item with you or can be shared to.
Only pocket accounts that have confirmed their email address will be represented as a Friend.
Historically client's had a `local_friend_id` field that it would use as the identity client side, however doing this requires
a bunch of extra complexity to "resolve" or set the `friend_id` that the server generated for it.
This allowed the clients to have an id for it before it spoke to the server.
"""
type Friend @_deprecated @figment(related_to: "SendToFriendFeature") {
    "Server assigned id or for temporary client side only friends, the email address the user"
    friend_id: String @id

    avatar_url: Url

    "TODO what?"
    email: EmailAddress

    first_name: String

    last_name: String

    "Display name"
    name: String

    username: String

    "Time most recently shared to via Send to Friend"
    time_shared: Timestamp
}

"""
An email address this user explicitly entered in when using {shared_to}. See {shared_to} for more details on Send to Friend.
"""
type AcEmail @_deprecated @figment(related_to: "SendToFriendFeature") {
    "The email address"
    email: EmailAddress @id

    "If this email address maps to a Pocket user and that email address is confirmed their {Friend.friend_id}, otherwise 0 if there is no pocket account or they haven't confirmed their email and we can't trust they own this email."
    friend_id: String

    "The last known time this email was shared to"
    time_shared: Timestamp
}

"""
Describes a recipient of a Send to Friend share, part of {shared_to}
"""
input StfRecipient @_deprecated @figment(related_to: "SendToFriendFeature") {
    "If known, the {Friend} `friend_id` of the recipient. If not known, then see `email`."
    friend_id: String

    "If the `friend_id` is not known, an email address to send the share to."
    email: EmailAddress

    "Optional. Can pass an local id that the server will return to you in the v3/send response of this action to help you set the `friend_id` on the local {Friend} instance. See {shared_to} for more info."
    local_friend_id: String @_deprecated
}

"""
See getPendingShares
"""
type UnconfirmedShare @_deprecated @figment(related_to: "SendToFriendFeature") {
    email: String

    from: String
}

extend type Mutation {
    "Register this device to start receiving push notifications. Uses Firebase Messaging (previously called GCM and previously called C2DM)"
    register_push_v2(
        "See {PushType} for details" push_type: PushType
        "A unique device identifier. {guid} is ok for Android." device_identifier: String
        "The `push token` for the device" token: String
    ): Void
    @figment(related_to: "PushFeature")
    @figment(auth: "UserAuth")
    @figment(priority: "REMOTE")
    @figment(effect: "When we receive a registration for a device_identifier and the same app we will invalidate the old push_token for that application.")
    @figment(effect: "")
    @figment(effect: "All tokens will have a lifespan of 6 months after which the backend will ignore the token if it has not been updated.")
}

extend type Mutation {
    "Stop a token previously registered with {register_push_v2}"
    deregister_push_v2(
        "See {PushType} for details" push_type: PushType
        "A unique device identifier. {guid} is ok for Android." device_identifier: String
    ): Void
    @figment(related_to: "PushFeature")
    @figment(auth: "UserAuth")
    @figment(priority: "ASAP")
    @figment(effect: "Sets the expiration date of the token in the database to the current date.")
}

"""
identifies which apns topic to send iOS pushes to. Not applicable to Android, so always set to {.PRODUCTION} for Android.
"""
enum PushType @figment(related_to: "PushFeature") {
    "com.ideashower.ReadItLaterPro & production apns"
    PRODUCTION @figment(enum_value: "prod")

    "com.ideashower.ReadItLaterProAlphaNeue & production apns"
    ALPHA @figment(enum_value: "alpha")

    "com.ideashower.ReadItLaterPro & sandbox apns"
    PRODDEV @figment(enum_value: "proddev")

    "com.ideashower.ReadItLaterProAlphaNeue & sandbox apns"
    ALPHADEV @figment(enum_value: "alphadev")
}

"""
A "Highlights" topic. Note: in this context "highlights" means, old Pocket 5.0 highlights which highlighted the best content in your list. This is not related to the Highlighting feature.
"""
type Group @figment(related_to: "BadgesFeature") {
    "Unique id for the group"
    group_id: GroupId @id

    "Icon to display in the badge"
    icons: Icon

    "A description of this group"
    desc: LocalizedString

    "The name of the group, to be shown in the badge"
    name: LocalizedString

    "When displaying as a badge, use this color for its label and icon."
    badge_text_color: ThemedColor

    "When displaying as a badge, use this color for badge box."
    badge_color: ThemedColor

    "the pressed state of badge_text_color."
    badge_text_color_pressed: ThemedColor

    "the pressed state of badge_color."
    badge_color_pressed: ThemedColor
}

enum GroupId @figment(related_to: "BadgesFeature") {
    BEST_OF @figment(enum_value: "1")
    TRENDING @figment(enum_value: "2")
}

type DiscoverTopic @figment(related_to: "DiscoverFeature") @figment(related_to: "TopicsFeature") {
    "Friendly name to display to user."
    display_name: String

    "Internal topic key. For use in requests like {DiscoverTopicFeed}."
    topic: String

    "Slug to use in urls for this topic."
    topic_slug: String

    "True if the topic should be featured in the list of topics."
    is_promoted: Boolean

    "name for curator label applied during item approval."
    curator_label: String

    "(optional) Text to appear on topic page/collection heading."
    display_note: String
}

"""
List of topics for Discover Topic pages.
"""
type DiscoverTopicList @figment(related_to: "DiscoverFeature") @figment(related_to: "TopicsFeature") @figment(auth: "NoAuth") @figment(address: "discover/topicList") @unique {
    topics: [DiscoverTopic]
}

"""
Recommendations for Pocket's Discover Topic pages.
"""
type DiscoverTopicFeed @figment(related_to: "DiscoverFeature") @figment(related_to: "TopicsFeature") @figment(auth: "NoAuth") @figment(address: "discover/topics") {
    "A topic name, provided by {DiscoverTopic.topic}. For a list of suggested/available topics {DiscoverTopicList} may be useful."
    topics: String @id

    "Maximum number of curated items to return."
    curated_count: Int @id

    "Maximum number of algorithmic items to return."
    algorithmic_count: Int @id

    "A list of curated recs."
    curated: [FeedItem]

    "A list of algorithmic recs."
    algorithmic: [FeedItem]
}

"""
Get the Recommended feed. Be default it combines general recs and social recs from those you follow.
However, apps should switch to using {discover} for general recs instead of this feed and have a separate screen for social recs, which you can get via this feed and {.feed_class}.
"""
type feed @figment(related_to: "DiscoverFeature") @figment(auth: "UserAuth") @figment(address: "feed") {
    "Version of the API to use. Set to 4"
    version: String @id

    "The maximum number of elements to return. You may receive less than this number. If you recieve 0 it means there are no more pages of elements to get."
    count: Int @id

    "0-indexed. The position in the list to start the return of elements. For example 0, returns from the beginning, 5 skips the first 5 elements. Use with count to load segments of a larger list."
    offset: Int @id

    "optional param, return a feed of only recs from profiles you follow.  If not set, this will include the default mixture of social and general recs."
    feed_class: FeedClass @id

    "the feed or empty if there are no results for the `count` and `offset`"
    feed: [FeedItem] @derives(reactive: ".feed.reported") @derives(reactive: ".feed.post.deleted") @derives(reactive: ".feed.post.original_post.deleted") @derives(reactive: ".feed.post.profile.is_following") @derives(reactive: "Account.premium_features") @derives(instructions: "Calculated on server.") @derives(instructions: "Clients can:") @derives(instructions: "  * Remove any where {FeedItem.reported} = true, {FeedItem.post.deleted} = true or {FeedItem.post.original_post.deleted} = true") @derives(instructions: "  * If {Account.premium_features} contains {PremiumFeature.AD_FREE}, remove any where {FeedItem.impression_info} is non null (meaning it is a spoc)") @derives(instructions: "  * Remove any feed items where {FeedItem.post.profile.is_following} = false and {FeedItem.impression_info} is null (meaning it can filter out people they stop following)")
}

"""
specifies which type of feed to return. If not set, will default to a mixture of social and general recs.
"""
enum FeedClass {
    SocialFeed
}

"""
Deprecated. Use {getSlateLineup} instead.
Get the Discover feed.
"""
type discover @_deprecated @figment(related_to: "DiscoverFeature") @figment(auth: "UserOptionalAuth") @figment(address: "discover") {
    "The maximum number of elements to return. You may receive less than this number. If you recieve 0 it means there are no more pages of elements to get."
    count: Int @id

    "0-indexed. The position in the list to start the return of elements. For example 0, returns from the beginning, 5 skips the first 5 elements. Use with count to load segments of a larger list."
    offset: Int @id

    "the feed or empty if there are no results for the `count` and `offset`"
    feed: [FeedItem]
}

"""
A recommendation in a Discover product. Basically an {Item} with some additional meta data useful for recommendation feeds. There are a few flavors of feed item to be aware of:
1. A General Rec. If there is no `post` and no `impression_info` it is a general rec.
2. A Spoc. A sponsored post. If there is a `impression_info`, this is a spoc.
3. A Social Rec. A recommendation someone else made. If there is a `post` and the `profile` belongs to someone else.
4. My Rec. A rec the auth'd user made. If there is a `post` and the `profile` `uid` matches the user
"""
type FeedItem @figment(related_to: "DiscoverFeature") {
    "A unique id for this feed item, the server may return the same {Item} and fields but a completely different feed_item_id. These are relatively short lived."
    feed_item_id: String @id

    "Optional. Some additional values for displaying this"
    format: FeedItemFormat

    "Optional. If provided, this should be used as the thumbnail instead of the default."
    image: Image

    "The underlying item"
    item: Item

    "Request for how the client should open this when the user clicks it"
    open_as: OpenAs

    "Optional. If this is a social rec, this will be non null"
    post: Post

    "TODO what is this?"
    rec_src: String

    "Optional. A 0-index sort order, depending on the query that returned this. (Deprecation: Sort Ids are a pattern we should try to avoid in the future, the APIs should just return arrays in the order they are intended. This should also be remapped to the parent query, it shouldn't be here in the thing itself.)"
    sort_id: Int @deprecated

    "The user has reported this, do not show it to them any more"
    reported: Boolean @local

    "Present if the editorial team wants to adjust the display properties of this item in the feed."
    curated_info: CuratedInfo

    "The client can track this field in analytics events, so we know what side the recommendations were on."
    experiment: RecItExperiment @deprecated

    "Identifies the recommendation that generated this FeedItem for analytics purposes."
    rec_id: String

    "The most appropriate title to show"
    display_title: String @local @derives(first_available: [".curated_info.title", ".item.display_title"])

    "The most appropriate excerpt to show"
    display_excerpt: String @local @derives(first_available: [".curated_info.excerpt", ".item.excerpt"])

    "The most appropriate image to show as a thumbnail"
    display_thumbnail: Url @local @derives(first_available: [".curated_info.image_src", ".impression_info.display.image.src", ".image.src", ".item.display_thumbnail"])

    "Deprecated, used to optionally represent SPOC data. See {AdzerkDecision}"
    impression_info: ImpressionInfo @deprecated
}

extend type CuratedInfo {
    "A display url for this content"
    image_src: Url @figment(client_api_alias: "imageSrc")
}

enum OpenAs @figment(related_to: "DiscoverFeature") {
    "Open as article view"
    article

    "Open as original web page"
    web

    "Open the premium upsell/feature screen"
    premium
}

type FeedItemFormat {
    "A header to display above the rec"
    tile_header: LinkedText
}

"""
Part of RecIt
"""
enum RecItModule @_deprecated {
    "syndicated recommendations based on the article"
    syndicated_article

    "recommendations from the same publisher"
    syndicated_publisher

    "After/end of article recommendations"
    after_article_android

    "Recommendations accessed via Discover"
    discovery_android
}

enum RecItEventType @_deprecated {
    ITEM_IMPRESSION @figment(enum_value: "0")
    ITEM_CLICK @figment(enum_value: "1")
    SAVE_CLICK @figment(enum_value: "2")
}

enum RecItExperiment @_deprecated {
    "Best of recommendations for the after article module (web and android) using pubspread."
    doc2vec_best_article_pubspread @figment(name: "doc2vec-best-article-pubspread")

    "Curated recommendations for the after article module (web and android) using pubspread."
    doc2vec_curated_article_pubspread @figment(name: "doc2vec-curated-article-pubspread")
}

"""
Article recommendations from RecIt, given a specific item
"""
type DiscoverRecIt @_deprecated @figment(address: "discover/recIt") {
    "RecIt module name"
    module: RecItModule @id

    "{Item.item_id} for which to get recommendations"
    item_id: String @id

    "Maximum number of search results to return"
    count: Int @id

    "RecIt experiment"
    experiment: RecItExperiment @id

    recommendations: [FeedItem]
}

"""
Personalization profile for a user.
Apps need this to build {UnleashProperties} to pass to {getUnleashAssignments}.
"""
type DiscoverRecItUserProfile @_deprecated @figment(auth: "UserAuth") @figment(address: "discover/recIt/userProfile") @unique {
    "Identifiers for user models"
    user_models: [String]
}

"""
A public profile of a user.
"""
type Profile @figment(related_to: "SocialFeature") @figment(related_to: "UserAccountFeature") {
    # Fields specific to the profile, no matter where this model is found.
    "Unique per profile, an id for this profile"
    uid: String @id

    "Url to an avatar image"
    avatar_url: String

    "Bio"
    description: EscapedString

    "Number of people this user follows"
    follow_count: Int @derives(reactive: "UserFollow") @derives(instructions: "To calculate: Count the number of {UserFollow} where {UserFollow.user_id} is {.uid}") @derives(instructions: "Clients will not have all of that info, so they should increment/deincrement when a {UserFollow} with {UserFollow.user_id} equal to {.uid}, is created or updated such that {UserFollow.status} is true.")

    "Number of people following this user"
    follower_count: Int @derives(reactive: "UserFollow") @derives(instructions: "To calculate: Count the number of {UserFollow} where {UserFollow.follow_user_id} is {.uid}") @derives(instructions: "Clients will not have all of that info, so they should increment/deincrement when a {UserFollow} with {UserFollow.follow_user_id} equal to {.uid}, is created or updated such that {UserFollow.status} is true.")

    "Display name such as `Carl Sagan`"
    name: EscapedString

    "Username"
    username: String

    # Fields specific to the logged in user, in relation to this profile.
    "Whether or not the logged in user is following this profile. `0`=false `1`=true"
    is_following: Boolean @derives(reactive: "UserFollow") @derives(instructions: "To calculate: See if there is a {UserFollow} with the {UserFollow.follow_user_id} matching the logged in user") @derives(instructions: "Clients will not have all of that info, so they can look for changes to a {UserFollow} whose {UserFollow.user_id} is the logged in user and {UserFollow.user_id} and {UserFollow.follow_user_id} is {.uid} and setting this to its {UserFollow.status}")

    # Fields that are part of the parent thing that need to be migrated to use remap instead of being here TODO
    "0-index position within a list returned from a query/endpoint. (Deprecation: Sort Ids are a pattern we should try to avoid in the future, the APIs should just return arrays in the order they are intended. This should also be remapped to the parent query, it shouldn't be here in the thing itself.)"
    sort_id: Int @deprecated

    type: SuggestionsType
}

enum SuggestionsType @figment(related_to: "SocialFeature") @figment(related_to: "SearchFeature") {
    "General suggestions"
    pocket

    "Suggestions from people you know on Facebook. This requires Facebook has been connected. Note: Mobile clients stopped supporting this option in early 2019"
    facebook @deprecated

    "Suggestions from people you know on Twitter. This requires Twitter has been connected."
    twitter

    "Suggestions from people you have in your contacts. This requires contacts have been connected."
    contacts
}

"""
Query a specific {Profile}.
"""
type getProfile @figment(related_to: "SocialFeature") @figment(auth: "UserAuth") @figment(address: "getProfile") {
    "Version of the API to use. Set to 2"
    version: String @id

    "The user's username or uid"
    profile_key: String @id

    "The queried profile"
    profile: Profile
}

extend type Mutation {
    "Create a new {Post} or repost an existing one."
    share_post(
        "The {Item}.item_id of the content to post, if not known, can use `url` instead." item_id: String
        "The url of the content to post. Can alternatively use `item_id`." url: Url
        "If reposting, the the {Post.post_id} of the post you are reposting." original_post_id: String
        "An optional comment" comment: String
        "An optional quote from the content" quote: String
        "Where to post" channels: [PostChannel]
        "Where to post" services: [PostService]
    ): Void
    @figment(related_to: "SocialFeature")
    @figment(auth: "UserAuth")
    @figment(priority: "ASAP")
    @figment(effect: "Create a new {Post} for this user's profile.")
    @figment(effect: "If a {.original_post_id} is included, it will repost it instead.")
    @figment(effect: "* If reposting with no comment or quote is included it will just reference the existing post, no new post_id is created.")
    @figment(effect: "* If reposting with a comment or quote, a new post with its own post_id is created.")
    @figment(effect: "* You may not repost your own post, so the {Post} where {Post.post_id} is {.original_post_id}, its {Post.profile.uid} cannot be the uid of the logged in user.")
    @figment(effect: "Clients have to rely on v3 for most changes here, but if {.original_post_id} is set, then it can:")
    @figment(effect: "  * Create or find a {PostRepostStatus} where:")
    @figment(effect: "     * {PostRepostStatus.post_id} is {.original_post_id}")
    @figment(effect: "     * {PostRepostStatus.profile_id} is the {Account.user_id} of the logged in account")
    @figment(effect: "  Set its {PostRepostStatus.status} to true")
    @figment(effect: "  Set its {PostRepostStatus.time_added} to {.time}")
    @figment(effect: "  If the post is not already reposted then also find the post by matching {Post.post_id} and {.original_post_id} and update:")
    @figment(effect: "  * Set {Post.repost_status} to true")
    @figment(effect: "  * Add 1 to {Post.repost_count.count}")
}

enum PostChannel @figment(related_to: "SocialFeature") @figment(related_to: "SharingFeature") {
    "Recommends the item, posting it on your public pocket profile"
    public_profile
}

enum PostService @figment(related_to: "SocialFeature") @figment(related_to: "SharingFeature") {
    "Note: Mobile clients stopped supporting this around the Pocket 7 launch in late 2018"
    facebook

    twitter
}

extend type Mutation {
    "Delete a {Post} that you've previously posted. (Only the user that posted it can delete it). See {report_feed_item} for hiding it from a feed."
    post_delete(
        "{Post.post_id} of the post to delete" post_id: String
    ): Void
    @figment(related_to: "SocialFeature")
    @figment(auth: "UserAuth")
    @figment(priority: "ASAP")
    @figment(effect: "Backend:")
    @figment(effect: "  TODO need to flush out more details on how this impacts reposts, and repost_counts")
    @figment(effect: "Clients:")
    @figment(effect: "  Find the post matching {Post.post_id} with {.post_id} and:")
    @figment(effect: "      * Set {Post.deleted} to true")
}

"""
A public recommendation someone has made. Typically found within a {FeedItem}
"""
type Post @figment(related_to: "SocialFeature") {
    # Values specific to the post itself
    "A unique id for this post"
    post_id: String @id

    "Optional. A comment the user made about this"
    comment: EscapedString

    feed_item_id: String

    "Some additional display info"
    format: PostFormat

    "The `item_id` of the {Item} that was posted"
    item_id: String

    "How many people have liked this post. Count of {PostLikeStatus} where {PostLikeStatus.post_id} is {.post_id} and {PostLikeStatus.status} is true"
    like_count: PostCount

    "Who posted it"
    profile: Profile

    "Optional. Part of the content they want to quote in their post"
    quote: EscapedString

    "How many people have reposted this post. Count of {PostRepostStatus} where {PostRepostStatus.post_id} is {.post_id} and {PostRepostStatus.status} is true"
    repost_count: PostCount

    "When it was posted"
    time_shared: Timestamp

    "TODO what is this? assuming it is related to when the user liked/reposted this post?"
    original_post: Post

    # Values specific to the auth'd user in relation to this post
    "if the user liked this"
    like_status: Boolean

    "if the user reposted this"
    repost_status: Boolean

    "TODO what is this? assuming it is related to when the user liked/reposted this post?"
    updated_at: String

    "Only needed client side briefly to communicate post deletes"
    deleted: Boolean
}

"""
Contents of the `post_count` object.
"""
type PostCount @figment(related_to: "SocialFeature") {
    "The count"
    count: Int

    "A url to open to see more details on who/what is included in this number"
    destination_url: String
}

"""
Contents of the `format` object.
"""
type PostFormat @figment(related_to: "SocialFeature") {
    "If this post is shown in the Reader as attribution, put this text below the name of the person that posted it. Typically this is used to indicate it was a repost and by whom"
    post_header: LinkedText
}

"""
Query a specific {Post}.
"""
type getPost @figment(related_to: "SocialFeature") @figment(auth: "UserAuth") @figment(address: "getPost") {
    "The id of the {Post}"
    post_id: String @id

    "The username or uid of the {Profile} that posted it"
    profile_key: String @id

    "The queried {Post} as a {FeedItem}"
    post: FeedItem
}

"""
Get the feed of recommendations someone (a {Profile}) has made.
"""
type getProfileFeed @figment(related_to: "SocialFeature") @figment(auth: "UserAuth") @figment(address: "getProfileFeed") {
    "Version of the API to use. Set to 5"
    version: String @id

    "The maximum number of elements to return. You may receive less than this number. If you recieve 0 it means there are no more pages of elements to get."
    count: Int @id

    "Either the username or uid of the {Profile} to get posts from"
    profile_key: String @id

    "0-indexed. The position in the list to start the return of elements. For example 0, returns from the beginning, 5 skips the first 5 elements. Use with count to load segments of a larger list."
    offset: Int @id

    "the feed or empty if there are no results for the `count` and `offset`"
    feed: [FeedItem] @derives(reactive: ".feed.reported") @derives(reactive: ".feed.post.deleted") @derives(reactive: ".feed.post.original_post.deleted") @derives(reactive: "Account.premium_features") @derives(instructions: "calculated on server") @derives(instructions: "Clients can:") @derives(instructions: "  * Remove any where {FeedItem.reported} = true, {FeedItem.post.deleted} = true or {FeedItem.post.original_post.deleted} = true") @derives(instructions: "  * If {Account.premium_features} contains {PremiumFeature.AD_FREE}, remove any where {FeedItem.impression_info} is non null (meaning it is a spoc)")
}

extend type Mutation {
    """
    "Like" a {Post}
    """
    post_like(
        "{Post.post_id} of the post to like" post_id: String
    ): Void
    @figment(related_to: "SocialFeature")
    @figment(related_to: "LikingFeature")
    @figment(auth: "UserAuth")
    @figment(priority: "ASAP")
    @figment(effect: "Create or find a {PostLikeStatus} where:")
    @figment(effect: "  * {PostLikeStatus.post_id} is {.post_id}")
    @figment(effect: "  * {PostLikeStatus.profile_id} is the {Account.user_id} of the logged in account")
    @figment(effect: "Set its {PostLikeStatus.status} to true")
    @figment(effect: "Set its {PostLikeStatus.time_added} to {.time}")
    @figment(effect: "If the post is not already liked then also find the post by matching {Post.post_id} and {.post_id} and update:")
    @figment(effect: "  * Set {Post.like_status} to true")
    @figment(effect: "  * Add 1 to {Post.like_count.count}")
}

extend type Mutation {
    "Unlike a {Post}"
    post_remove_like(
        "{Post.post_id} of the post to unlike" post_id: String
    ): Void
    @figment(related_to: "SocialFeature")
    @figment(related_to: "LikingFeature")
    @figment(priority: "ASAP")
    @figment(effect: "Find a {PostLikeStatus} where:")
    @figment(effect: "  * {PostLikeStatus.post_id} is {.post_id}")
    @figment(effect: "  * {PostLikeStatus.profile_id} is the {Account.user_id} of the logged in account")
    @figment(effect: "Set its {PostLikeStatus.status} to false")
    @figment(effect: "Find the post by matching {Post.post_id} and {.post_id} and update:")
    @figment(effect: "  * Set {Post.like_status} to false")
    @figment(effect: "  * Subtract 1 from {Post.like_count.count} (only do this if {Post.like_status} was previously true)")
}

"""
Get a list of {Profile} that liked a {Post}
"""
type getLikes @figment(related_to: "SocialFeature") @figment(auth: "UserAuth") @figment(address: "getLikes") {
    "Set to 1"
    version: String @id

    "The `post_id` of a {Post} to get a list of likes for"
    post_id: String @id

    "The maximum number of elements to return. You may receive less than this number. If you recieve 0 it means there are no more pages of elements to get."
    count: Int @id

    "0-indexed. The position in the list to start the return of elements. For example 0, returns from the beginning, 5 skips the first 5 elements. Use with count to load segments of a larger list."
    offset: Int @id

    "{Profile}s that liked this post"
    profiles: [Profile] @derives(reactive: "PostLikeStatus") @derives(reactive: "Post.like_status") @derives(instructions: "To calculate, get a list of {PostLikeStatus} where {PostLikeStatus.post_id} = {.post_id} and {PostLikeStatus.status} is true, sorted by {PostLikeStatus.time_added} DESC and then use the {PostLikeStatus.profile_id} list to create a list of {Profile}s in that same order matching {Profile.uid}.") @derives(instructions: "Clients likely can only do the following kinds of updates locally:") @derives(instructions: "  * If the logged in user unlikes a post and they are currently listed in {.profiles}, you can remove their profile from the list. You can detect this by looking for a changed {PostLikeStatus} with a {PostLikeStatus.profile_id} matching the logged in {Account.profile.uid} and a {PostLikeStatus.post_id} = {.post_id}, that is deleted or ends up with a {PostLikeStatus.status} of false. Can also look for a {Post} whose {Post.post_id} matches {.post_id} and check if {Post.like_status} is now false.") @derives(instructions: "  * If the logged in user likes a post and the {.offset} and {.count} is such that you can assume this is the top of the list, you can add their profile to first position of {.profiles}. You can detect this by looking for a changed {PostLikeStatus} with a {PostLikeStatus.profile_id} matching the logged in {Account.profile.uid} and a {PostLikeStatus.post_id} = {.post_id}, ends up with a {PostLikeStatus.status} of true. Can also look for a {Post} whose {Post.post_id} matches {.post_id} and check if {Post.like_status} is now true.")
}

extend type Mutation {
    "un-repost a {Post}"
    post_remove_repost(
        "{Post.post_id} of the post to un-repost" post_id: String
    ): Void
    @figment(related_to: "SocialFeature")
    @figment(related_to: "RepostingFeature")
    @figment(priority: "ASAP")
    @figment(effect: "TODO there is some confusing stuff with reposts, as it might be a pure repost or a new post that needs to be deleted?")
    @figment(effect: "TODO what happens if a user invokes this on their own post? is that possible?")
    @figment(effect: "Create or find a {PostRepostStatus} where:")
    @figment(effect: "  * {PostRepostStatus.post_id} is {.post_id}")
    @figment(effect: "  * {PostRepostStatus.profile_id} is the {Account.user_id} of the logged in account")
    @figment(effect: "Set its {PostRepostStatus.status} to false")
    @figment(effect: "Find the post by matching {Post.post_id} and {.post_id} and update:")
    @figment(effect: "  * Set {Post.repost_status} to false")
    @figment(effect: "  * Subtract 1 from {Post.repost_count.count} (only do this if {Post.repost_status} was previously true)")
}

"""
Get a list of {Profile}s that reposted a {Post}.
"""
type getReposts @figment(related_to: "SocialFeature") @figment(auth: "UserAuth") @figment(address: "getReposts") {
    "Version of the API to use. Set to 1"
    version: String @id

    "The maximum number of elements to return. You may receive less than this number. If you recieve 0 it means there are no more pages of elements to get."
    count: Int @id

    "The `post_id` of a {Post} to get a list of reposts for"
    post_id: String @id

    "0-indexed. The position in the list to start the return of elements. For example 0, returns from the beginning, 5 skips the first 5 elements. Use with count to load segments of a larger list."
    offset: Int @id

    "{Profile}s that reposted this post"
    profiles: [Profile] @derives(reactive: "PostRepostStatus") @derives(reactive: "Post.repost_status") @derives(instructions: "To calculate, get a list of {PostRepostStatus} where {PostRepostStatus.post_id} = {.post_id} and {PostRepostStatus.status} is true, sorted by {PostRepostStatus.time_added} DESC and then use the {PostRepostStatus.profile_id} list to create a list of {Profile}s in that same order matching {Profile.uid}.") @derives(instructions: "Clients likely can only do the following kinds of updates locally:") @derives(instructions: "  * If the logged in user unreposts and they are currently listed in {.profiles}, you can remove their profile from the list. You can detect this by looking for a changed {PostRepostStatus} with a {PostRepostStatus.profile_id} matching the logged in {Account.profile.uid} and a {PostRepostStatus.post_id} = {.post_id}, that is deleted or ends up with a {PostRepostStatus.status} of false. Can also look for a {Post} whose {Post.post_id} matches {.post_id} and check if {Post.repost_status} is now false.") @derives(instructions: "  * If the logged in user reposts a post and the {.offset} and {.count} is such that you can assume this is the top of the list, you can add their profile to first position of {.profiles}. You can detect this by looking for a changed {PostRepostStatus} with a {PostRepostStatus.profile_id} matching the logged in {Account.profile.uid} and a {PostRepostStatus.post_id} = {.post_id}, ends up with a {PostRepostStatus.status} of true. Can also look for a {Post} whose {Post.post_id} matches {.post_id} and check if {Post.repost_status} is now true.")
}

extend type Mutation {
    "Begin following a {Profile}"
    follow_user(
        "A list of {Profile.uid} to follow" user_list: [String]
    ): Void
    @figment(related_to: "FollowFeature")
    @figment(auth: "UserAuth")
    @figment(priority: "ASAP")
    @figment(effect: "For all uids in {.user_list}, create a {UserFollow} where:")
    @figment(effect: "  * {UserFollow.user_id} is the {Account.user_id} of the logged in user")
    @figment(effect: "  * {UserFollow.follow_user_id} id from {.user_list}")
    @figment(effect: "  * {UserFollow.time_updated} is {.time}")
    @figment(effect: "  * {UserFollow.status} is true (only used client side)")
}

extend type Mutation {
    "Stop following a {Profile}"
    unfollow_user(
        "A list of {Profile.uid} to unfollow" user_list: [String]
    ): Void
    @figment(related_to: "FollowFeature")
    @figment(auth: "UserAuth")
    @figment(priority: "ASAP")
    @figment(effect: "For all uids in {.user_list}, find a {UserFollow} where:")
    @figment(effect: "  * {UserFollow.user_id} is the {Account.user_id} of the logged in user")
    @figment(effect: "  * {UserFollow.follow_user_id} id from {.user_list}")
    @figment(effect: "And then either delete it or update it to:")
    @figment(effect: "  * {UserFollow.time_updated} is {.time}")
    @figment(effect: "  * {UserFollow.status} is false (only used client side)")
}

extend type Mutation {
    "Follow all {Profile}s that are suggested from a service."
    follow_all_users(
        social_service: SuggestionsType
    ): Void
    @figment(related_to: "FollowFeature")
    @figment(auth: "UserAuth")
    @figment(priority: "ASAP")
    @figment(effect: "For all {Profile}s found in {getSuggestedFollows.suggested_follows} where {getSuggestedFollows.social_service} is {.social_service} do the same as {follow_user} for each {Profile.uid}.")
    @figment(effect: "Clients may not know all profiles here and may only be able to do a best attempt and require syncing with v3 to get updated states.")
}

"""
Get a list of {Profile}s that follows a certain {Profile}.
"""
type getFollowers @figment(related_to: "SocialFeature") @figment(auth: "UserAuth") @figment(address: "getFollowers") {
    "Version of the API to use. Set to 2"
    version: String @id

    "Either the username or uid of the {Profile} to get a list of followers for"
    profile_key: String @id

    "The maximum number of elements to return. You may receive less than this number. If you recieve 0 it means there are no more pages of elements to get."
    count: Int @id

    "0-indexed. The position in the list to start the return of elements. For example 0, returns from the beginning, 5 skips the first 5 elements. Use with count to load segments of a larger list."
    offset: Int @id

    "A list of {Profile} or empty if there are no results for the `count` and `offset`"
    profiles: [Profile] @derives(reactive: "UserFollow") @derives(instructions: "To calculate, find all {UserFollow} where {UserFollow.follow_user_id} the uid related to the {.profile_key}, TODO what sort order?") @derives(instructions: "Clients don't have enough information to derive this or add entries or sort") @derives(instructions: "So the best that clients can do is remove a profile from this list if they detect a {UserFollow.status} becoming false where the {UserFollow.follow_user_id} is a uid matching the {.profile_key}, which again, if the client doesn't have, they can't derive.") @derives(instructions: "So at the current level of information returned, really the clients should probably not add, remove or reorder this list and depend on refreshing from the server to change which profiles are in here.")
}

"""
Get a list of {Profile}s that a certain {Profile} follows.
"""
type getFollowing @figment(related_to: "SocialFeature") @figment(auth: "UserAuth") @figment(address: "getFollowing") {
    "Version of the API to use. Set to 2"
    version: String @id

    "The maximum number of elements to return. You may receive less than this number. If you recieve 0 it means there are no more pages of elements to get."
    count: Int @id

    "Either the username or uid of the {Profile} to get a list of who they follow"
    profile_key: String @id

    "0-indexed. The position in the list to start the return of elements. For example 0, returns from the beginning, 5 skips the first 5 elements. Use with count to load segments of a larger list."
    offset: Int @id

    "A list of {Profile} or empty if there are no results for the `count` and `offset`"
    profiles: [Profile] @derives(reactive: "UserFollow") @derives(instructions: "To calculate, find all {UserFollow} where {UserFollow.user_id} the uid related to the {.profile_key}, TODO what sort order?") @derives(instructions: "Clients don't have enough information to derive this or add entries or sort") @derives(instructions: "So the best that clients can do is remove a profile from this list if they detect a {UserFollow.status} becoming false where the {UserFollow.user_id} is a uid matching the {.profile_key}, which again, if the client doesn't have, they can't derive.") @derives(instructions: "So at the current level of information returned, really the clients should probably not add, remove or reorder this list and depend on refreshing from the server to change which profiles are in here.")
}

"""
Get a list of suggested {Profile} for the user. If the response is an error and the X-Error-Code is 5400 it means that the social_service has not been connected to Pocket or has expired and needs to be reconnected.
"""
type getSuggestedFollows @figment(related_to: "SocialFeature") @figment(related_to: "SearchFeature") @figment(auth: "UserAuth") @figment(address: "getSuggestedFollows") {
    "The maximum number of elements to return. You may receive less than this number. If you receive 0 it means there are no more pages of elements to get."
    count: Int @id

    "The type of suggestions to return."
    social_service: SuggestionsType @id

    "0-indexed. The position in the list to start the return of elements. For example 0, returns from the beginning, 5 skips the first 5 elements. Use with count to load segments of a larger list."
    offset: Int @id

    "Version of the API to use. Set to 2"
    version: String @id

    "The total number of suggestions available."
    total: Int

    "A list of {Profile} or empty if there are no results for the `count` and `offset`"
    suggested_follows: [Profile]
}

extend type Mutation {
    """
    Upload hashes of contacts that are related to the user to help find friends to follow. **Apps must get explicit permission from a user to do this and only hashes are uploaded, never send actual contacts**.
    original specs https://docs.google.com/document/d/10e8h_nRj--ylWOmHbXYcTXUXWn-67jnZyKzBRIKEQtI/edit#heading=h.t1d6z4brfwpv
    """
    friendFinderSync(
        "A list of hashed contacts. If you have more than 300 to send, please split it in multiple requests" hashes: [ContactHash]
    ): Void @figment(related_to: "SocialFeature") @figment(related_to: "ConnectingSocialFeature") @figment(auth: "UserAuth") @figment(address: "friendFinderSync")
}

"""
To create a hash: 1. Trim and normalize the contact info. Trim whitespace. For email's reduce to lowercase. 2. Form a string with the following values v1:contact:type:salt. The contact is normalized email or phone number, type is the type value used in the contact object. For the salt, ask a server ops person for it. 3. Take that entire string, such as v1:max@getpocket.com:1:salt and create a SHA256 hash of it.
"""
input ContactHash @figment(related_to: "SocialFeature") {
    "A hashed string of the contact info"
    hash: String

    "The type of contact info `hash` contains."
    type: ContactType
}

enum ContactType @figment(related_to: "SocialFeature") {
    EMAIL @figment(enum_value: "1")

    PHONE_NUMBER @figment(enum_value: "2")
}

extend type Mutation {
    """
    Register a social access token to allow Pocket to interact with a user's social networks for features like posting recommendations. Be sure to check the X-Error-Code if something fails
    Some error codes:
    400 Bad Request
    Unable to register with service.
    5400

    400 Bad Request
    Missing user.
    5401

    400 Bad Request
    Missing service.
    5402

    400 Bad Request
    Invalid access token.
    5403
    Twitter only

    400 Bad Request
    Invalid access token secret.
    5404
    Twitter only

    400 Bad Request
    Invalid access token.
    5405
    Facebook only

    400 Bad Request
    Invalid signed request.
    5406
    Facebook only
    """
    registerSocialToken(
        "The service you are uploading tokens for. Either `facebook` or `twitter`" social_service: PostService
        "Details about the tokens" token_info: SocialToken
    ): Void
    @figment(related_to: "ConnectingSocialFeature")
    @figment(auth: "UserAuth")
    @figment(address: "registerSocialToken")
    @figment(effect: "Update connected accounts")
}

input SocialToken @figment(related_to: "SocialFeature") {
    "The Facebook access token"
    access_token: String

    "The Twitter oauth token"
    oauth_token: String

    "The Twitter oauth token secret"
    oauth_token_secret: String
}

extend type Mutation {
    "Mark an Article has incorrectly parsed"
    reportArticleView(
        "The given url of the article to that has a problem" url: Url
    ): Void @figment(related_to: "ArticleViewFeature") @figment(auth: "UserAuth") @figment(address: "reportArticleView")
}

extend type Mutation {
    """
    Report/Hide a {FeedItem} or {Post}.
    Typically a recommendation will have some kind of menu or hide option. When that option is invoked you can ask the user why they are reporting/hiding it and fire this action with the reason.
    Here is some example prompt text and what reason to send for each choice:

    "Why don't you want to see this?"
    * "It's not relevant to me" -> {ReportReason.LOW_QUALITY}
    * "I've already seen it" -> {ReportReason.SEEN}
    * "It makes me feel uncomfortable" -> {ReportReason.OFFENSIVE}
    * "It's spam" -> {ReportReason.SPAM}

    The prompt can also include a text link of [Why was this item recommended to me?](https://help.getpocket.com/customer/portal/articles/2061219)
    Deprecated in favor of {ReportEntity/1-0-0} which uses Snowplow.
    """
    report_feed_item(
        "The {FeedItem.feed_item_id} of the feed item to report." feed_item_id: String
        "Reason for reporting" reason: ReportReason
    ): Void
    @deprecated
    @figment(related_to: "DiscoverFeature")
    @figment(related_to: "ReportContentFeature")
    @figment(auth: "UserAuth")
    @figment(priority: "ASAP")
    @figment(effect: "Hide this item from the user and do not show it again")
    @figment(effect: "Clients can do this by finding a {FeedItem} matching {FeedItem.feed_item_id} with {.feed_item_id} and setting {FeedItem.reported} to true.")
}

enum ReportReason @figment(related_to: "DiscoverFeature") {
    LOW_QUALITY @figment(enum_value: "3")

    SPAM @figment(enum_value: "2")

    OFFENSIVE @figment(enum_value: "5")

    SEEN @figment(enum_value: "4")

    SEE_FEWER @figment(enum_value: "6")
}

extend enum PremiumFeature @figment(related_to: "PocketPremiumFeature")
@enum_value(name: "PERMANENT_LIBRARY", value: "library")
@enum_value(name: "SUGGESTED_TAGS", value: "suggested_tags")
@enum_value(name: "PREMIUM_SEARCH", value: "premium_search")
@enum_value(name: "AD_FREE", value: "ad_free")
@enum_value(name: "ANNOTATIONS", value: "annotations")

enum PremiumAllTimeStatus @figment(related_to: "PocketPremiumFeature") {
    "user has never had Premium"
    NEVER @figment(enum_value: "0")

    "user currently has Premium subscription that is active NOTE: User will still show as 1 if they turn off auto-renew or have otherwise canceled, but the expiration date hasn't hit yet"
    ACTIVE @figment(enum_value: "1")

    "user previously had Premium, but subscription is in a cancelled state. This means they either do not currently have premium -or- they still have premium, but subscription is set to cancel when it expires, e.g. no longer recurring."
    EXPIRED @figment(enum_value: "2")
}

extend type Mutation {
    """
    Notify the Pocket API that a Premium purchase has been made. This tells the server to validate it and then activate Premium for this user.
    Some X-Error-Codes that might occur:
    * 5300 : ERROR_PURCHASE_INVALID_SOURCE
    * 5301 : ERROR_PURCHASE_VALIDATION
    * 5318 : ERROR_PURCHASE_ALREADY_HAS_PREMIUM

    ## Examples

    iOS Payload

    ```json
    {
      "source": "itunes",
      "transaction_info": "SGVyZeKAmXMgdG8gdGhlIGNyYXp5IG9uZXMsIHRoZSBtaXNmaXRzLCB0aGUgcmViZWxzLg==",
      "transaction_type": "purchase",
      "amount": "4.99", //note for small denomiation currencies this is 499
      "currency": "USD",
      "amount_display": "$4.99" //note for small denomiation currencies this is 499
    }
    ```


    Android Payload

    ```json
    {
      "source": "googleplay",
      "transaction_info": "{\"packageName\":\"com.ideashower.readitlater.pro\",\"productId\":\"pocket.premium.1month\",\"purchaseToken\":\"12341\",\"orderId\":\"GPA.1234-1231-1231-12313\",\"purchaseTime\":123456,\"purchaseState\":0,\"autoRenewing\":1}",
      "transaction_type": "purchase",
      "amount": "4990000", //note for small denomiation currencies this is 499.
      "currency": "USD",
      "amount_display": "$4.99"
    }
    ```
    """
    purchase(
        "The store's unique id for this 'product'" product_id: String
        "A blob of data specific to the `source`.\nFor iOS a [base64 encoded receipt blob](https:\/\/developer.apple.com\/documentation\/storekit\/original_api_for_in-app_purchase\/validating_receipts_with_the_app_store).\nFor Android a json encoded array of transaction data. Both are considered the receipt object from the stores." transaction_info: String
        "The display price" amount_display: String
        "The currency code of the currency it was purchased in" currency: String
        "The name of the store\/service it was purchased on. Current values are `googleplay` and `itunes`" source: String
        "The amount it was purchased for in micros" amount: String
        "Either `purchase` for new orders, or `restore` if this was a restoration of a purchase they already made and they manually pressed a restore option" transaction_type: String
    ): Void
    @figment(related_to: "PocketPremiumFeature")
    @figment(auth: "UserAuth")
    @figment(address: "purchase")
    @figment(priority: "REMOTE_RETRYABLE")
    @figment(effect: "Update Account premium status")
}

"""
Get the premium purchase status for the authenticated user.
If the server returns a 400 status code and 5302 for X-Error-Code then the user does not have any purchases.
"""
type purchase_status @figment(related_to: "PocketPremiumFeature") @figment(auth: "UserAuth") @figment(address: "purchase_status") @unique {
    "A list of premium features for this user and their status"
    features: [PremiumFeatureStatus]

    "Current subscription info"
    subscription_info: PremiumSubscriptionInfo
}

"""
Part of {purchase_status}
"""
type PremiumFeatureStatus {
    faq_link: Url

    name: String

    "0 means not active, see the status_text for more details. 1 means active"
    status: Int

    status_text: String
}

"""
The user's current Pocket Premium purchase status
Part of {purchase_status}
"""
type PremiumSubscriptionInfo {
    "If it is not set to renew, then when it will expire in the format of `yyyy-MM-dd HH:mm:ss`"
    active_until_date: String

    display_amount: String

    is_active: Boolean

    order_id: String

    "When it was purchased in the format of `yyyy-MM-dd HH:mm:ss`"
    purchase_date: DateString

    "When it is due to renew in the format of `yyyy-MM-dd HH:mm:ss`"
    renew_date: DateString

    "Keyword for where it was purchased."
    source: PurchaseSource

    "Display text for where it was purchased"
    source_display: String

    status: Int

    subscription_id: String

    subscription_source: Int

    subscription_type: String

    subscription_type_id: Int

    usd_amount: String
}

enum PurchaseSource @figment(related_to: "PocketPremiumFeature") {
    web

    googleplay

    itunes
}

extend type Mutation {
    "Tell the server to update the permanent library cache for this item to the current state online."
    refresh_library(
        "The {Item.item_id} to refresh its library version of" item_id: String
    ): Void @figment(related_to: "PermanentLibraryFeature") @figment(auth: "UserAuth") @figment(priority: "ASAP")
}

extend type Mutation {
    "Add a {SearchQuery} to the recent searches"
    recent_search(
        "The {SearchQuery.search}" search: String
        "The {SearchQuery.context_key}" scxt_key: SearchContextKey
        "The {SearchQuery.context_value}" scxt_val: String
    ): Void
    @figment(related_to: "RecentSearchFeature")
    @figment(auth: "UserAuth")
    @figment(priority: "ASAP")
    @figment(effect: "Create a {SearchQuery} with")
    @figment(effect: "  * {SearchQuery.search} as {.search}")
    @figment(effect: "  * {SearchQuery.context_key} as {.scxt_key}")
    @figment(effect: "  * {SearchQuery.context_value} as {.scxt_val}")
    @figment(effect: "  * {SearchQuery.time} as {.time}")
    @figment(effect: "Add (or if already present, move) to the top of {RecentSearches.searches} and any {get.recent_searches}")
}

"""
See {SearchQuery.context_key}
"""
enum SearchContextKey @figment(related_to: "SearchFeature") {
    "Search within a filter. {SearchQuery.context_value} will be one of {SearchContextIn}."
    in

    "Search within a tag filter. {SearchQuery.context_value} will be the tag."
    tag
}

"""
See {SearchQuery.context_value} and {SearchContextKey}
"""
enum SearchContextIn @figment(related_to: "SearchFeature") {
    "Search within Favorites"
    favorites

    "Search within Shared to Me"
    shared

    "Search within Articles"
    article

    "Search within Videos"
    video

    "Search within Images"
    image

    quick_reads

    medium_reads

    long_reads

    very_long_reads
}

"""
Represents a search query.
"""
type SearchQuery @figment(related_to: "SearchFeature") {
    "Optional. Search context allows you to search within filters like favorites, tags, etc. This field specifies what type {.context_value} will contain."
    context_key: SearchContextKey

    "Optional. If not null, and {.context_key} is {SearchContextKey.in} then this will be one of the {SearchContextIn} values. If it is {SearchContextKey.tag} this will be the name of the tag."
    context_value: String

    "The user entered search term/query"
    search: String

    "(Deprecation: Sort Ids are a pattern we should try to avoid in the future, the APIs should just return arrays in the order they are intended. This should also be remapped to the parent query, it shouldn't be here in the thing itself.)"
    sort_id: String @deprecated

    "The time the user made this search"
    time: Timestamp
}

"""
gets a list of payloads (setup files such as fonts) to download after a user has authenticated
"""
type getPostAuthPayload @figment(related_to: "PocketPremiumFeature") @figment(related_to: "UiToolsFeature") @figment(auth: "UserAuth") @figment(address: "getPostAuthPayload") @unique {
    payloads: Payloads
}

"""
a String key to the premium fonts to download. Part of {getPostAuthPayload}
"""
type Payloads {
    premium_fonts_zip: Url
}

"""
Get a list of {SuggestedTag} for an {Item}. This is a Premium only feature
"""
type suggested_tags @figment(related_to: "TaggingFeature") @figment(related_to: "PocketPremiumFeature") @figment(auth: "UserAuth") @figment(address: "suggested_tags") {
    "The `given_url` of the {Item} to get suggested tags for"
    url: String @id

    "The `item_id` of the {Item} to get suggested tags for"
    item_id: String @id

    "A list of tags"
    suggested_tags: [SuggestedTag]
}

"""
Part of {suggested_tags}
"""
type SuggestedTag {
    score: String

    tag: String
}

"""
Deprecated in favor of {AdzerkDecision}
Details about a Spoc (Sponsored Content)
"""
type ImpressionInfo @_deprecated @figment(related_to: "SponsoredContentFeature") {
    "A unique id for this spoc impression. A new one may be generated at anytime, even for the same {FeedItem}. These are not long lived objects"
    impression_id: String @id

    "Definitions of how this should be displayed"
    display: ImpressionInfoDisplay

    type: String

    "Tracking tags that clients must send at the same time as {sp_impression_loaded}"
    tags: SpocTags
}

"""
Some overrides and display details for showing a Spoc. See {ImpressionInfo.display}
"""
type ImpressionInfoDisplay @_deprecated {
    "Optional. If present, use this instead of the default for the domain. Note, this may not be a domain, it could be any string"
    domain: String

    "Some additional formatting"
    format: ImpressionInfoFormat

    "Optional. If present, use this as a thumbnail instead of the default for the item"
    image: Image

    "Optional. The position within a collection that this should be display. 0-index"
    position: Int
}

"""
See {ImpressionInfoDisplay.format}
"""
type ImpressionInfoFormat @_deprecated {
    "Optional. If present, use this header instead of the default"
    header: ImpressionInfoHeader
}

"""
See {ImpressionInfoFormat.header}
"""
type ImpressionInfoHeader @_deprecated {
    "The text to display to identify this as a sponsored post to the user."
    sponsored_label: String
}

type SpocTags @_deprecated {
    "A list of <img> tracking tags that should be fired at the same time as {sp_impression_loaded}. For mobile, just extract the `src` and connect/ping/open the url in the background to register the track."
    im: [String]
}

extend type Mutation {
    """
    Track a loaded event of a spoc's {ImpressionInfo} from {FeedItem}
    Deprecated, switched to Adzerk pv_wt's, see {CxtEvent.sp_impression_loaded}.
    """
    sp_impression_loaded(
        "The {ImpressionInfo.impression_id} of the spoc" cxt_impression_id: String
    ): Void @deprecated @figment(related_to: "SponsoredContentFeature") @figment(auth: "UserAuth") @figment(priority: "ASAP")

    """
    Track an impression event of a spoc's {ImpressionInfo} from {FeedItem}
    Deprecated, switched to Adzerk pv_wt's, see {CxtEvent.sp_impression_viewed}.
    """
    sp_impression_viewed(
        "The {ImpressionInfo.impression_id} of the spoc" cxt_impression_id: String
        "The device's advertising id (If the user has enabled do not track on their device, do not send this id, leave this blank)" cxt_device_id: String
    ): Void @deprecated @figment(related_to: "SponsoredContentFeature") @figment(auth: "UserAuth") @figment(priority: "ASAP")

    """
    Track a click event of a spoc's {ImpressionInfo} from {FeedItem}
    Deprecated, switched to Adzerk pv_wt's, see {CxtEvent.sp_impression_clicked}.
    """
    sp_impression_clicked(
        "The {ImpressionInfo.impression_id} of the spoc" cxt_impression_id: String
        "The device's advertising id (If the user has enabled do not track on their device, do not send this id, leave this blank)" cxt_device_id: String
    ): Void @deprecated @figment(related_to: "SponsoredContentFeature") @figment(auth: "UserAuth") @figment(priority: "ASAP")

    """
    Track a failed impression event of a spoc's {ImpressionInfo} from {FeedItem}
    Deprecated, switched to Adzerk pv_wt's, see {CxtEvent.sp_impression_failed}.
    """
    sp_impression_failed(
        "The {ImpressionInfo.impression_id} of the spoc" cxt_impression_id: String
    ): Void @deprecated @figment(related_to: "SponsoredContentFeature") @figment(auth: "UserAuth") @figment(priority: "ASAP")
}

"""
Returns a list of global, platform wide {UserSetting} a user can modify.
"""
type getUserSettings @figment(related_to: "SettingsFeature") @figment(auth: "UserAuth") @figment(address: "getUserSettings") {
    "Version of the API to use. Set to 1"
    version: String @id

    "The category of settings you want to return."
    category_id: UserSettingCategory @id

    "A list of settings for the `category_id`"
    settings: [UserSetting]
}

type UserSetting @figment(related_to: "SettingsFeature") {
    key: UserSettingKey @id
    default_description: String
    disabled_description: String
    title: String
    type: SettingType
    value: String
    category_id: UserSettingCategory

    "TODO is this always a Url?"
    action: String
}

enum UserSettingCategory @figment(related_to: "SettingsFeature") {
    "Mobile Notifications Settings. User's controls over what notifications they receive in their apps"
    MOBILE_NOTIFICATIONS @figment(enum_value: "1")
}

enum SettingType @figment(related_to: "SettingsFeature") {
    header
    page
    switch
}

enum UserSettingKey @figment(related_to: "SettingsFeature") {
    "Product Updates setting in Mobile Notifications Settings."
    notifications_pocket_product_updates
}


extend type Mutation {
    "Change a {UserSetting}."
    update_user_setting(
        "The {UserSetting.key} of the setting to change" key: String
        "The new {UserSetting.value} to update it to" value: String
    ): Void
    @figment(related_to: "SettingsFeature")
    @figment(auth: "UserAuth")
    @figment(priority: "ASAP")
    @figment(effect: "Find a setting by matching {UserSetting.key} to {.key} and set {UserSetting.value} to {.value}")
}

type ThemedColor @figment(related_to: "UiToolsFeature") {
    """
    Color to use in light theme, or by default. Hex color like "#ffffff"
    """
    light: HexColor

    """
    Color to use in sepia theme. Optional, if not supplied, use light. Hex color like "#ffffff"
    """
    sepia: HexColor @deprecated

    """
    Color to use in dark theme. Optional, if not supplied, use light. Hex color like "#ffffff"
    """
    dark: HexColor

    """
    Color to use in black theme. Optional, if not supplied, use dark. Hex color like "#ffffff"
    """
    black: HexColor @deprecated
}

"""
A image that can be loaded remotely from a url, provided in several different resolutions so devices can choose what best fits their needs.
"""
type Icon @figment(related_to: "UiToolsFeature") {
    "A url for 1.33x (tvpi) devices"
    _1_33x: String @figment(name: "1_33x")

    "A url for 1.5x (hdpi) devices"
    _1_5x: String @figment(name: "1_5x")

    "A url for 1x (mdpi) devices"
    _1x: String @figment(name: "1x")

    "A url for 2x (xhdpi) devices"
    _2x: String @figment(name: "2x")

    "A url for 3x (xxhdpi) devices"
    _3x: String @figment(name: "3x")

    "A url for 4x (xxxhdpi) devices"
    _4x: String @figment(name: "4x")

    "TODO verify, is this the right key? A url for devices that can load a vector pdf"
    pdf: String
}

"""
Text that has hyperlinks within it.
"""
type LinkedText @figment(related_to: "UiToolsFeature") {
    "An icon to display ahead of the text"
    icon: Icon

    "The raw text"
    text: String

    "The hyperlinks"
    text_urls: [LinkedTextLink]
}

type LinkedTextLink @figment(related_to: "UiToolsFeature") {
    "index 0 is the start point within the text, and index 1 is the length of the link in characters"
    indices: [Int]

    "The link"
    url: Url
}

"""
Translations of a String. Each key is a local code in the format of ln-CT where ln is the two digit language code and CT is the two digit country code. Such as `en-US`, `zh-CN`. If no match for your language is found, use the default `en-US` value.
"""
type LocalizedString @figment(related_to: "UiToolsFeature") @figment(related_to: "StringLocalizationFeature") {
    "English US, and Default for non-provided languages"
    en_US: String @figment(name: "en-US")

    fr_FR: String @figment(name: "fr-FR")

    it_IT: String @figment(name: "it-IT")

    ru_RU: String @figment(name: "ru-RU")

    es_ES: String @figment(name: "es-ES")

    fr_CA: String @figment(name: "fr-CA")

    de_DE: String @figment(name: "de-DE")

    ja_JP: String @figment(name: "ja-JP")

    es_LA: String @figment(name: "es-LA")

    zh_CN: String @figment(name: "zh-CN")

    zh_TW: String @figment(name: "zh-TW")

    pt_PT: String @figment(name: "pt-PT")

    pt_BR: String @figment(name: "pt-BR")

    pl_PL: String @figment(name: "pl-PL")

    ko_KR: String @figment(name: "ko-KR")

    nl_NL: String @figment(name: "nl-NL")
}

"""
This is a left over remnant of the [Extended Attributions framework](https://docs.google.com/document/d/1Gni0TRYRl49oJc_I6Qw9F-lYA2u2J_0C6CODz5muDTE/edit) that has been removed.
This aspect is still used to attribute posts to saves.
To attribute a post, create an instance where {.attribution_type_id} is {AttributionTypeId.POST} and {.source_id} is {Post.post_id}
"""
input AttributionSaveInfo @figment(related_to: "AttributionFeature") {
    "The type of attribution being saved."
    attribution_type_id: AttributionTypeId

    "Some id, see {AttributionTypeId} for what this value will be"
    source_id: String
}

enum AttributionTypeId @figment(related_to: "AttributionFeature") {
    "The {AttributionSaveInfo.source_id} will be a {Post.post_id}"
    POST @figment(enum_value: "102")
}

"""
Old way of attaching some meta data to items, still used for at least twitter status ids?
"""
type ItemMeta {
    "Twitter status id"
    _1: String @figment(name: "1")
}

extend type Mutation {
    "Request the server sends an email to the user's primary email, a guide on how to setup/use a certain feature."
    email(
        template: EmailGuideTemplate
        type: EmailGuideType
    ): Void @figment(related_to: "HelpFeature") @figment(related_to: "EmailingFeature") @figment(auth: "UserAuth") @figment(address: "email")
}

enum EmailGuideTemplate @figment(related_to: "HelpFeature") {
    "Information on how to setup their computer to use Pocket"
    browser_setup_gs @figment(name: "browser-setup-gs")
}

enum EmailGuideType @figment(related_to: "HelpFeature") {
    "TODO not sure what this indicates, but it is used with {EmailGuideTemplate.browser-setup-gs}"
    pocket_help
}

extend type Mutation {
    "Resend a confirm-email email to one of a user's registered emails. See {addAlias}."
    resendEmailConfirmation(
        "The email address to resend it to" email: String
    ): Void @figment(related_to: "HelpFeature") @figment(related_to: "UserAccountFeature") @figment(related_to: "EmailingFeature") @figment(auth: "UserAuth") @figment(address: "resendEmailConfirmation")
}

"""
Get feature flags for the auth'd user.
Deprecated in favor of Unleash
"""
type checkFeatures @_deprecated @figment(related_to: "AbTestingFeature") @figment(related_to: "FeatureFlagsFeature") @figment(auth: "UserAuth") @figment(address: "checkFeatures") @unique {
    "The feature flags"
    features: Features
}

"""
Feature flags from {checkFeatures}
"""
type Features @_deprecated {
    "Whether or not the Chrome extension should show Recs on Save"
    show_recs: Boolean

    "Whether or not to show the Premium Upsells on iOS"
    show_ios_premium_upsells: Boolean

    "Whether or not to show the list counts test. (Never fully implemented)"
    show_list_counts: Boolean

    "Whether or not to show the premium icon on toolbar in My List"
    show_premium_icon: Boolean

    "Whether to show a user to new sign ups, and the url of the survey to show"
    show_new_user_survey: NewUserSurveyFeatures
}

"""
A group of feature flags controlling showing a survey prompt to new users.
"""
type NewUserSurveyFeatures @_deprecated {
    "Whether or not to show the prompt."
    show_survey: Boolean

    "Survey URL to open if they agree to take it."
    survey_url: Url
}

"""
Details about an ab test. Note The name of the test is not in the model, it is provided as part of the response of abt. This would be nice to include in the model itself later.
"""
type AbTest @_deprecated @figment(related_to: "AbTestingFeature") {
    "The name of the variant the user has been assigned to"
    option: String

    "An optional value that can be used in a variety of ways to allow variants to control text or functionality"
    value: String
}

extend type Mutation {
    """
    Track a user to an ab test variant
    Deprecated in favor of Snowplow
    """
    pv_ab(
        ab_test: String
        ab_test_option: String
    ): Void @deprecated @figment(related_to: "AbTestingFeature") @figment(auth: "GuidAuth") @figment(priority: "WHENEVER")
}

"""
Action context is a bit of a snapshot of the app, device and ui state in the moment the action occurred. It provides the how, why, where an action occurred for our analytics. This can be used in aggregate to better understand how certain features are being used to help inform product decisions and priorities.
Context can be attached to any action, the values it contains describes things like what state the device is in, what screen of the app the user is looking at or interacting with.
Context appears as additional fields in an Action. Context should never be functionality required, anything that is required in order to fully complete a particular Action should be included in that Action's definition, not the Context. Context should strictly be for analytic use.
Deprecated in favor of Snowplow
"""
input ActionContext @_deprecated @figment(related_to: "V3AnalyticsFeature") {
    # Fields that will typically be included if there is user facing ui or some kind of interaction involved. One or more of these is typically included with every action.
    "What the user interacted with to trigger an action."
    cxt_ui: CxtUi

    "The screen the user was on at the time of the action"
    cxt_view: CxtView

    "Used in a variety of ways, see data spec's for more details."
    cxt_section: CxtSection

    # Fields that describe the app/device state at the time of the action. These are typically included with every action.
    "The device's internet connection status at the time of the action"
    cxt_online: OnlineStatus

    "The app's color theme at the time of the action"
    cxt_theme: AppTheme

    "The app's orientation at the time of the action"
    cxt_orient: DeviceOrientation

    "Session id, typically a timestamp of when the session began"
    sid: String

    # Fields that likely will only be included when {.cxt_view} is {CxtView.list}
    "For actions that occur in the user's list, what layout mode was it in at the time of the action? Either \"tile\" or \"list\"."
    cxt_list_view: String

    "For actions that occur in the user's list, the content type filter, if any, that the list was filtered by."
    cxt_content_type: AnalyticsContentType

    "For actions that occur in the user's list, the list's sort"
    cxt_sort: ItemSortKey

    "If an action is related to a {Group} or a list where an action occurred is filtered by one, its {Group.group_id}"
    cxt_grouping: GroupId

    "For actions that occur in a search view, the search term at the time of the action"
    cxt_search: String

    "For actions that occur in Explore Search, the search term at the time of the action. TODO deprecate?"
    cxt_search_term: String

    "For actions that occur in the user's list, the tag it was filtered by, if any."
    cxt_tag: String

    # Fields that may be used when viewing a list or feed of elements
    "For actions that occur on an element in a list, that elements position in the list. (1 is the first position, not 0)"
    cxt_index: Int

    # Fields that likely will only be included when {.cxt_view} is {CxtView.reader}
    "For actions that occur in the reader, the type of view that the user was in when the action occurred"
    cxt_reader_view: PositionType

    "For actions that occur in the reader, the percentage of the way through the page that the top edge of the screen is located at. 0-100"
    cxt_top: String

    "For actions that occur in the reader, the percentage of the way through the page that the bottom edge of the screen is located at. 0-100"
    cxt_bottom: String

    "For actions that occur in the reader, whether or not the reader is in fullscreen mode"
    cxt_fullscreen: Boolean

    # Fields that likely will only be included when interacting with attribution in the {CxtView.reader}
    "For actions that occur on an attribution, its type id."
    cxt_attribution_type: String

    "For actions that occur on an attribution, its id."
    cxt_attribution_id: String

    "For actions that occur on an attribution, its position amongst any list of attributions (1 is first position, not 0)"
    cxt_attribution_index: String

    "The name of the attribution action"
    cxt_action_name: String

    # Fields that likely will only be included when {.cxt_view} is {CxtView.add_tags} or {CxtView.edit_tags}
    "For actions that occur in the screen that lets users add or change the tags on an item. The number of tags already tagged on the item when the screen loaded. Originally defined here https://docs.google.com/spreadsheets/d/1EoHspwg4sKJ9JMvVWSlJ0aG8TBQQ-HDAD4yE0zNIeAE/edit#gid=0"
    cxt_tags_cnt: Int

    "For actions that occur in the screen that lets users add or change the tags on an item. The number of suggested tags presented to the user on the screen. Originally defined here https://docs.google.com/spreadsheets/d/1EoHspwg4sKJ9JMvVWSlJ0aG8TBQQ-HDAD4yE0zNIeAE/edit#gid=0"
    cxt_suggested_available: Int

    "For actions that occur in the screen that lets users add or change the tags on an item. The number of items the user added to the item by tapping a tag in the list of tags.  Originally defined here https://docs.google.com/spreadsheets/d/1EoHspwg4sKJ9JMvVWSlJ0aG8TBQQ-HDAD4yE0zNIeAE/edit#gid=0"
    cxt_tap_cnt: Int

    "For actions that occur in the screen that lets users add or change the tags on an item. The number of items the user added to the item by tapping a suggested tag.  Originally defined here https://docs.google.com/spreadsheets/d/1EoHspwg4sKJ9JMvVWSlJ0aG8TBQQ-HDAD4yE0zNIeAE/edit#gid=0"
    cxt_suggested_cnt: Int

    "For actions that occur in the screen that lets users add or change the tags on an item. The number of tags that were added to the item by manually typing in the tag in the text field. Originally defined here https://docs.google.com/spreadsheets/d/1EoHspwg4sKJ9JMvVWSlJ0aG8TBQQ-HDAD4yE0zNIeAE/edit#gid=0"
    cxt_enter_cnt: Int

    "For actions that occur in the screen that lets users add or change the tags on an item. The number of tags the user removed from the item.  Originally defined here https://docs.google.com/spreadsheets/d/1EoHspwg4sKJ9JMvVWSlJ0aG8TBQQ-HDAD4yE0zNIeAE/edit#gid=0"
    cxt_remove_cnt: Int

    "For actions that occur in the screen that displays a list of {Profile}s, the number of profiles displayed to the user"
    cxt_user_cnt: Int

    # Fields that likely will only be included when the ui is related to recs or social such as {FeedItem}, {Post} or {Profile}
    "If an action is related to a {FeedItem}, its {FeedItem.feed_item_id}"
    cxt_feed_item: String

    "If an action is related to a {Post}, its {Post.post_id}"
    cxt_post_id: String

    "If an action is related to a {Profile}, its {Profile.uid}"
    cxt_user_id: String

    "If an action is related to a {ImpressionInfo} (a spoc), its {ImpressionInfo.impression_id}"
    cxt_impression_id: String @_deprecated

    # Fields that likely will only be included when the ui is related to an {AdzerkSpoc}
    "If an action is related to an {AdzerkSpoc}, its {AdzerkSpoc.decision.adId}"
    cxt_ad_id: String

    "If an action is related to an {AdzerkSpoc}, its {AdzerkSpoc.decision.creativeId}"
    cxt_creative_id: String

    "If an action is related to an {AdzerkSpoc}, its {AdzerkSpoc.placement.siteId}"
    cxt_site_id: String

    "If an action is related to an {AdzerkSpoc}, its {AdzerkSpoc.placement.zoneIds[0]}"
    cxt_zone_id: String

    # Fields you may see included when an action is related to an {Item} and its data
    "If an action is related to a {Item}, its {Item.item_id} if known"
    cxt_item_id: String

    "If an action is related to a {Annotation}, its {Annotation.annotation_id}"
    annotation_id: String

    "Item session id, used to track active item (reading/listening) sessions"
    item_session_id: String

    # Fields related to a pv event that tracks device specs.
    "For a pv event called `app_icon` - Density independent size (typically px/dpi) of the shortest dimension of the device's screen. Raw, full screen size, this value doesn't change on rotation or when on screen content changes."
    cxt_screen_short: Int

    "For a pv event called `app_icon` - Density independent size (typically px/dpi) of the longest dimension of the device's screen. Raw, full screen size, this value doesn't change on rotation or when on screen content changes."
    cxt_screen_long: Int

    "For a pv event called `app_icon` - The max heap size (available memory to the application) in mb"
    cxt_heap_size_mb: Int

    # Fields related to article recommendations powered by RecIt.
    "The RecIt experiment model"
    cxt_model: RecItExperiment @deprecated

    "String # The {FeedItem.rec_id} from this recommendation."
    cxt_rec_id: String

    "The {Item.item_id} of the source {Item} from which the recommendation was generated."
    cxt_synd_id: String

    "The module for this RecIt use."
    cxt_module: RecItModule @deprecated

    "The position of the item, using 0 based indexing."
    cxt_position: Int

    "The {Item.item_id} of this recommendation {Item}."
    cxt_rec_item_id: String

    "The type of RecIt event"
    type_id: RecItEventType @deprecated

    # Other misc.
    "Typically related to a {CxtView.notification} and the url that would be activated when the notification's main action is taken"
    cxt_url: String

    "For actions that occur in a listen view, the % of item listened to at time of event [0-100]"
    cxt_progress: Int
}

enum CxtSearchType @_deprecated @figment(related_to: "V3AnalyticsFeature") @figment(related_to: "SearchFeature") {
    "A user entered in a search"
    new

    "A user selected a recent search"
    recent
}

"""
Possible values for use in {ActionContext.cxt_ui}
These typically refer to the "trigger" or interaction point that caused an action to be fired, such as describing what button
Note: these values must be <= 20 characters
Deprecated in favor of Snowplow
"""
enum CxtUi @_deprecated @figment(related_to: "V3AnalyticsFeature") {
    "From the prompt that asks users if they want to save the url in their clipboard"
    clipboard

    "On Android, when a user saves to Pocket through the Android intent system, such as selecting Pocket from another app's share menu"
    intent

    "Same as `intent` but when the user has the Quick Save Actions overlay enabled"
    intent_w_overlay

    "The user tapped the back button"
    back

    "A universal/deep link from a pocket notification"
    url_scheme

    "From the list filter drawer"
    left_navigation_menu

    "From an item tile or row's menu. Such as when you long press / swipe an item in My List."
    item_menu

    "From the bulk edit menu"
    bulk_edit

    "Deprecated. From a recommendation card in the old Discover / social recommendations feed"
    feed_tile @deprecated

    "From the undo bar that appears after deleting or archiving"
    undo_bar

    "From the menu that appears in the Reader after long pressing a link in a. article or webpage."
    long_press

    "From the main toolbar. Typically this refers to the top app bar"
    toolbar

    "From clicking a link in the Reader. Normally this will be a  special kind of link like `Listen:` or `recommend:` which the parser can add to trigger an app feature from an article view. Not all articles have  this and may only be found in special cases or tests. Another place you might find this is in links within Publisher Messages at the end of an article. Some example domains that have these messages are the Verge and Nytimes"
    link

    "From changing the Article / Web toggle in the Reader"
    view_toggle

    "From a special link in the Article View that switches over to Web View"
    link_switch_view

    "From tapping a Retry button on an error message"
    error_try_again

    "From going through the site login feature"
    subscription_login @deprecated

    "From an error popup shown when there is an SSL certificate warning for a site they tried to load in the Reader"
    reader_back_ssl

    "From the permanent library refresh popup in the Reader"
    p_lib_update_button

    "From a controller outside of the reader. No longer in use."
    listen_remote

    "From a popup about an error that happened when trying to load something from their offline cache that is stored on an external storage device and no longer attached or is missing. This is likely from them retrying loading after resolving the issue."
    dialog_storage_locat

    "From the Settings screen"
    settings

    "From the logout process"
    logout

    "From the login process"
    login

    "From an external media control such as a headset, or a bluetooth speaker with media controls like play, pause skip next"
    media_button

    "From Reader attribution like Twitter or Extended attribution"
    attribution_actions

    "From opening a pocket.co short link"
    POCKET_CO @figment(enum_value: "pocket.co")

    "From opening a pocket universal or deep link"
    deep_link

    "From Listen's cover flow carousel"
    cover_flow

    "From Listen's progress scrubber"
    scrubber

    "From Listen's player controls"
    player

    "From Listen's play list"
    playlist

    "From Listen's controls in its collapsed/mini mode at the bottom of the screen"
    mini_player

    "From Listen's auto play next feature"
    played_next

    "From Listen's Next button"
    skip_next

    "From Listen's Previous button"
    skip_back

    "In the context of Listen, this means it was triggered from system/device media controls, such as a bluetooth headset or other features"
    background

    "From a view that displays a list of {Annotation}s"
    highlights

    "From or related to the Continue Reading view/popup"
    continue_reading

    "From an overflow menu, like on Android where there are three dots in the app bar that show you additional options in a popup"
    overflow

    "From the Discover feed"
    discover

    "From the Social Recs feed"
    social_recs

    "From an explore topic feed"
    topic

    "From the RecIt Similar Stories feed"
    recit @deprecated
}

"""
Possible values for {ActionContext.cxt_view}, {pv.view} or {pv_wt.view}
Typically these describe the screen or part of a screen or UX a user was interacting with or viewing when an action occurred.
It seems like {CxtSection} is quite similar and can be used interchangeably in some cases.
TODO would be good to work out some clarity between "view" and "section", but the general rule in the meantime is "view" refers to
the bigger picture screen, and section is more likely to be a part of a screen. For example view might refer to a screen and section might refer to a specific tab within that screen.
However these rules may be mixed in their actual usage.
Note: There are some cases where these names will be dynamic, but those will at least use one of the names below as a prefix.
Deprecated in favor of Snowplow
"""
enum CxtView @_deprecated @figment(related_to: "V3AnalyticsFeature") {
    """
    From the screen where you can add tags to item(s). Typically this is only when bulk editing, since when bulk editing you "add" tags to many rather than edit them. Also see {.edit_tags}
    """
    add_tags

    "SPOCs loaded from Adzerk ad-server."
    adzerk

    "Impression / click events for RecIt recommendations"
    syndicated_rec_test @deprecated

    "A bit unclear exactly when, but not specific to a screen, might be when the user tapped the app icon to open the app or even when the app is running in the background"
    app_icon

    "From attribution views in the reader, such as tweet, send to friend or social post attribution"
    attribution

    "On Android, a view that opens some url in an internal web view in the app rather than a browser"
    BasicWebViewActivity

    "The settings screen where you can change how much storage space the app can use for its offline cache"
    cache_settings

    "The confirmation screen you see after successfully purchasing premium"
    confirmation

    "A tab in {CxtSection.follow_people} where you can find people to follow from your contacts"
    contacts

    "A special settings screen that only appears on internal team builds"
    devconfig

    "A view in the reader that let's you change the display settings of articles and web pages"
    display_settings

    "A view that lets you change your account information like username, bio, emails, etc"
    edit_account

    "A view that lets you change your profile picture/avatar"
    edit_avatar_photo

    "A view that lets you change your account password"
    edit_password

    "From a screen where you can edit the tags on an item. Typically this is only when editing a single item. Also see {.add_tags}"
    edit_tags

    "A view shown to (typically new) users after log in / sign up that introduces them to how to use pocket"
    gsf

    "A recommendation feed (Social Reds / Discover). Analytics for the two are delineated via their cxt_ui"
    feed

    "A view that lists people that follow a profile. Also see {.following_list}"
    followers_list

    "A view that lists people that a profile follows. Also see {.followers_list}"
    following_list

    "A view that tells you that you have been comp'd pocket premium. Typically from a device partnership like Samsung Galaxy Gifts"
    gifted

    "A prefix for a view in the help section of the app. Will be followed by the name of the specific help page."
    help

    "A view that shows a list of available help topics or choices"
    help_list

    "A view that shows some options about how to save to pocket"
    how_to_save

    "Another name that is used in some cases for {.how_to_save}"
    howtoadd

    "Another name that is used in some cases for {.how_to_save}"
    howtosave

    "A bit unclear exactly, but current usages are an overflow menu and a popup menu of storage choices"
    menu

    "Used generically in a bunch of cases, meaning unclear other than just specifying the action is from a mobile app, but doesn't specify what screen"
    mobile

    "A view that shows people that liked a {Post}"
    likes

    "A view that shows My List and its various filters/variants such as Archive, Favorites, etc."
    list

    "A view related to the listen feature"
    listen

    "A view that shows listen settings"
    listen_settings @figment(name: "listen/settings")

    "A view that shows listen playback controls in a minimize, compact view"
    listen_mini_player @figment(name: "listen/mini_player")

    "A view that shows listen playback controls in likely a full screen or large view"
    listen_player @figment(name: "listen/player")

    "A view that shows log in / sign up options"
    login

    "A view related to {Notification} or a system device notification"
    notification

    "The Activity screen/tab/feature"
    notifications

    "A settings screen. Also see {.settings}"
    options

    "Unclear if this actually appears anywhere but a fallback name for the screen in mobile that shows a bottom nav of choices like My List, Discover, Activity etc."
    pocket

    "A screen in Android that users on a Kobo Arc tablet used to log into Pocket"
    PocketAuthorizeAppActivity

    "A view that shows status of your premium account"
    premium_settings

    "A view that shows a specific {Profile}"
    profile

    "The reader view, which is the screen where all content is viewed/read/watched"
    reader

    "A view that lets you zoom into an image in an article view or swipe through all images in an article view"
    reader_image_viewer

    "A view that you see after tapping repost, that lets you add a comment and confirm you want to repost"
    repost

    "A view that shows a list of people that reposted a post"
    reposts

    "A view that prompts a user to consider rating/reviewing pocket"
    review_prompt

    "an overlay view which appears when sharing to Pocket"
    save_extension

    "A view that where you can search your list"
    search

    """
    A view you see after selecting "Send to Friend" that lets you select who to send an item to and add a comment. Also see {shared_to}
    """
    send_to_friend

    "A another name for {.options}"
    settings

    "Part of the Site Logins feature. This view is for when there is no {PayWallTemplate} available for a site, this view lets you log into a site in a webview instead. This view is where you enter in the url of the site you want to log into. After entering that in, you will end up in {.subscription_custom_login_web}"
    subscription_custom_login @deprecated

    "Part of the Site Logins feature. This view is for when there is no {PayWallTemplate} available for a site, this view lets you log into a site in a webview instead."
    subscription_custom_login_web @deprecated

    "Part of the Site Logins feature, a view that shows you available sites to log into"
    subscription_list @deprecated

    "Part of the Site Logins feature, a view where you enter a username and password to a site you want to log into"
    subscription_login @deprecated

    "A tab in {CxtSection.follow_people} where you can find people to follow from pocket's suggestions"
    suggested

    "A tab in {CxtSection.follow_people} where you can find people to follow from pocket's suggestions"
    twitter

    "Views related to purchasing/upgrading to premium"
    upgrade

    "A view shown to users telling them they've upgrade to the latest version."
    whats_new
}

"""
Possible values for {ActionContext.cxt_section}, {pv.section} or {pv_wt.section}
A section or part of a UI that an action occurred in. Typically not an entire screen, but part of a screen or feature
though this is not always true. Historically we had not strongly defined this. See docs on {CxtView} for more details.
Note: There are some cases where these names will be dynamic, but those will at least use one of the names below as a prefix.
Deprecated in favor of Snowplow
"""
enum CxtSection @_deprecated @figment(related_to: "V3AnalyticsFeature") {
    "The ALL ITEMS tab in a search view. This is a premium only tab that lets you search all items, both {ItemStatus#UNREAD} and {ItemStatus#ARCHIVED} in one tab."
    all

    "Triggered from the app upgrading to a new version"
    app_upgrade

    "Triggered from the app upgrading to the sync engine release and completing the migration path"
    sync_upgrade

    "Any list, search or filter view that is limited to only {ItemStatus#ARCHIVED} items. This may be the ARCHIVE filter, the ARCHIVE tab in search or the ARCHIVE tab of a filter such as articles."
    archive

    "Related to the Auto Dark Theme feature, likely related to its settings changing or being turned on and off"
    auto_dark_mode

    """
    Related to the Listen setting "Auto Archive"
    """
    autoarchive_toggle

    """
    Related to the Listen setting "Auto Play Next"
    """
    autoplay_toggle

    "Related to completing onboarding or the final step of onboarding"
    complete

    "Related to the Continue Reading feature"
    continue_reading

    "Not strongly defined what this means"
    core

    "the Discover feed / tab"
    discover

    "Any list, search or filter view that is limited to only items where {Item#favorite} is true. This may be the FAVORITES filter or a search that has a Favorites context chip (a search that is limited to favorited items)"
    favorites

    "Related to or triggered from interaction with the filters menu, which is UI that lets you choose between lists like My List, Articles, Videos, Tags, etc"
    filters_menu

    "A view that shows you or helps you find other people to follow on pocket"
    follow_people

    "Related to the theme feature where Pocket will change to dark theme or light theme to match the current OS theme automatically."
    follow_system_theme

    "Related to onboarding screens shown (typically only to new users) after sign up / log in. This may be used as a prefix with page numbers following it."
    gsf

    "Related to in app Help screens"
    help

    "Related to an in app Help screen about how to save to Pocket"
    howtosave_help

    "Related to an in app Help screen about how to save to Pocket. Also see {.howtosave_help}"
    howtosave_list

    "Related to an unlaunched feature that showed list counts of each filter"
    list_counts

    "Related to a toast based variant of the Listen Discoverability messaging test. https://docs.google.com/document/d/19NDNSUeoz9cZNjjFDf8U-bWqlBOdD3PfdAuvYh97Iww/edit"
    listen_toast

    "Related to a tooltip based variant of the Listen Discoverability messaging test. https://docs.google.com/document/d/19NDNSUeoz9cZNjjFDf8U-bWqlBOdD3PfdAuvYh97Iww/edit"
    listen_tooltip

    "Interactions with the Listen player controls when in the maximized, full layout. Also see {.minimize}"
    maximize

    "Related to {UserMessage}"
    message

    "Interactions with the Listen player controls when in the minimized, compact layout. Also see {.maximize}"
    minimize

    "The screen that displays log in options"
    mobile_login

    "The screen that displays sign up options"
    mobile_signup

    "The mobile landing screen when logged out. Also see {.mobile_login} {.mobile_signup}"
    mobile_startup

    "Related to a menu that displays share options based on the OS/device, such as other apps that can be shared to directly on the device"
    native_sharesheet

    """
    Not strongly defined, but likely related to an event that tracks opening a screen. "open" is more typically found as a {pv.event} rather than section.
    """
    open

    "The app settings screen"
    options

    "Triggered from an overflow menu (sometimes also called kebab menu or 3 dots). Typically found in a toolbar where there are more options that visually fit as icons."
    overflow_menu

    "The screen shown when recommending an item on pocket, where you can add a comment and confirm before posting"
    pocket_sharesheet

    "Currently used on screens that show post counts, such as {CxtView.reposts} and {CxtView.likes}"
    post

    "Premium upsells that might appear in the app or the main premium/purchase screen"
    premium

    """
    No longer used, but was similar to {.premium} for a tested variant that had version of premium that only had "ad free" as its feature for a lower price
    """
    premium_adfree

    "Any list, search or filter view that is limited to only {ItemStatus#UNREAD} items. This may be My List, the My List tab in search or the My List tab of a filter such as articles."
    queue

    "Unclear where this might appear. Could be a case where an app thought it should have a section but it was in an expected state and didn't know which to use"
    unknown

    "Related to the rotation lock feature on mobile devices that lets you lock screen orientation"
    rotation_lock

    "Related to Listen's speed setting control"
    set_speed

    "Related to Listen's voice setting"
    set_voice

    "The settings screens. Also see {.options}"
    settings

    "The screen where you have selected an item to send to friend and are now adding a comment and/or selecting who to send it to."
    stf_sharesheet @deprecated

    "A badge on an item, such as Favorite, Best Of, Trending, a Tag, etc"
    tap_tag

    "Actions taken from the Reader's menu that shows when some text is selected on the page"
    text_selection_menu

    "Related to Theme selection"
    theme

    "saving an item from the add overlay"
    item_save

    "adding tags from the add overlay"
    add_tags

    "Search and sort at the top of My List painted door test. Deactivated 10/25, removed early November 2020."
    android_search_sort_test @deprecated

    """
    was used for an unreleased "premium" add overlay
    """
    save_extension_add_tags @deprecated
}

"""
Possible values of {pv_wt.source}
Note: There are some cases where these names will be dynamic, but those will at least use one of the names below as a prefix.
Deprecated in favor of Snowplow
"""
enum CxtSource @_deprecated @figment(related_to: "V3AnalyticsFeature") {
    "From the suggested tags premium upsell"
    tags

    "From a menu option on a sponsored post"
    sp

    "From premium settings"
    premium_settings

    "From a deep link / universal link like http://getpocket.com/premium"
    url_scheme

    "From a premium button or upsell on the profile page"
    profile

    "From a premium upsell when highlighting, such as when you try to highlight more than is available on a free account, or when attempting to highlight in guest mode"
    highlights

    "From a premium upsell on the list screen"
    list

    "From a premium upsell at the top of the list screen"
    top_of_list

    "From a premium upsell on the bottom of the reader"
    bottom_reader

    "From a premium upsell in display/text settings in the reader"
    display_settings

    "From a premium upsell in display/text settings in the reader"
    display_settings_upsell

    "From a premium upsell in the font picker in the reader"
    font

    "From a premium upsell in the font picker in the reader"
    font_upsell

    "A prefix used for events related to a {UserMessage}. The {UserMessage.message_id} will follow this prefix"
    message_

    "persistent snackbar in My List guest mode"
    bottom_list

    "the My List Listen icon in guest mode"
    listen_icon

    "the profile tab in guest mode"
    profile_tab

    "attempting to add tags in guest mode"
    add_tags

    "attempting to click Log in from settings"
    settings
}

"""
Possible values of {pv_wt.action_identifier} or {pv.event}
Some dynamic values not listed here:
* Some listen events may pass in a speed value, which could be a floating point signed number
* Some listen events may pass in the name of a voice
Deprecated in favor of Snowplow
"""
enum CxtEvent @_deprecated @figment(related_to: "V3AnalyticsFeature") {
    add_annotation
    archive
    articles

    "this was part a client side A/B test we rolled out to 100% in Sept 2020"
    assign_to_test @deprecated

    auth_cancelled
    bestof
    cancel
    cancel_annual
    cancel_monthly
    change_limit
    change_priority

    """
    was used for an unreleased "premium" add overlay
    """
    click_add_new_tag @deprecated

    click_add_tag
    click_annual

    """
    was used for clicking a "how to save" help button
    """
    click_apps @deprecated

    click_bottom_reader_upsell
    click_button
    click_button_0
    click_button_1
    click_close
    click_connect
    click_cta
    click_dismiss
    click_email_instructions
    click_follow_all
    click_learn_how
    click_listen_icon
    click_list_upsell
    click_monthly

    """
    was used for an unreleased "premium" add overlay
    """
    click_new_tag @deprecated

    click_page_saved

    """
    was used for an unreleased "premium" add overlay
    """
    click_save_tags @deprecated

    """
    was used for an unreleased "premium" add overlay
    """
    click_see_all @deprecated

    "was used for Send to Friend"
    click_share @deprecated

    click_signup
    click_similar_stories

    "when clicking a Discover topic"
    click_topic

    click_try_listen

    """
    was used for an unreleased "premium" add overlay
    """
    click_x @deprecated

    confirm_annual
    confirm_monthly
    dark
    disable
    disabled
    dismiss
    dismiss_cta
    dismiss_list_upsell
    edit_tags
    email_me_click
    email_me_skip
    enable
    enabled
    error_annual
    error_monthly
    favorites
    find_in_page
    font
    highlights
    images
    light
    my_list
    msg_delivered
    msg_not_shown
    open
    open_display_settings
    open_help
    open_highlights
    open_overflow_menu

    """
    was used for an unreleased "premium" add overlay
    """
    populate_tags @deprecated

    referrer
    save
    scroll_across
    scroll_to_bottom
    sdcard_setup_denied
    sdcard_setup_fs_denied
    sdcard_setup_missing
    sdcard_setup_success
    sepia @deprecated
    share
    shared_to_me

    "Fire when a SPOC is clicked."
    sp_impression_clicked

    "Fire when a SPOC fails to render."
    sp_impression_failed

    "Fire when a SPOC is hid."
    sp_impression_hid

    "Fire when a SPOC is loaded."
    sp_impression_loaded

    "Fire when a SPOC is saved."
    sp_impression_saved

    "Fire when a SPOC is viewed."
    sp_impression_viewed

    submit
    success
    tag
    threshold_default
    threshold_manual
    translate
    trending
    untagged
    videos
    view_animation
    view_bottom_reader_upsell
    view_display_settings_upsell
    view_font_upsell
    view_footer
    view_highlights_upsell
    view_list_upsell
    view_message
    view_page
    view_tags_upsell
    view_upsell
    view_welcome_survey

    "Search bar click in the {CxtSection.android_search_sort_test}"
    click_search @deprecated

    "Sort icon click in the {CxtSection.android_search_sort_test}"
    click_sort @deprecated

    "Yes click in the popup in the {CxtSection.android_search_sort_test}"
    click_yes @deprecated

    "No click in the popup in the {CxtSection.android_search_sort_test}"
    click_no @deprecated
}

"""
Possible values of {pv_wt.page}
Some dynamic values that may also appear are:
* The version number of the app
* A {UserMessage.message_id}
Deprecated in favor of Snowplow
"""
enum CxtPage @_deprecated @figment(related_to: "V3AnalyticsFeature") {
    email
    google
    firefox
    apple
    forgot_password
    add_annotation
    add_tags
    installation
    reader
    display_settings
    cache_settings
    upgrade
    upgrade_complete
    confirmation
    list

    "this was part a client side A/B test we rolled out to 100% in Sept 2020"
    recit_ab_test_android @deprecated
    survey
    feed
    topic
}

"""
Deprecated in favor of Snowplow
"""
enum OnlineStatus @_deprecated @figment(related_to: "V3AnalyticsFeature") {
    OFFLINE @figment(enum_value: "1")
    WIFI @figment(enum_value: "2")
    MOBILE @figment(enum_value: "3")
}

"""
Deprecated in favor of Snowplow
"""
enum DeviceOrientation @_deprecated @figment(related_to: "V3AnalyticsFeature") {
    PORTRAIT @figment(enum_value: "1")
    LANDSCAPE @figment(enum_value: "2")
}

"""
Deprecated in favor of Snowplow
"""
enum AppTheme @_deprecated @figment(related_to: "V3AnalyticsFeature") {
    LIGHT @figment(enum_value: "0")
    SEPIA @figment(enum_value: "1") @deprecated
    DARK @figment(enum_value: "2")
    BLACK @figment(enum_value: "3") @deprecated
    UNKNOWN @figment(enum_value: "4")
}

"""
For {ActionContext.cxt_content_type}
Deprecated in favor of Snowplow
"""
enum AnalyticsContentType @_deprecated @figment(related_to: "V3AnalyticsFeature") {
    shared_to_me
    video
    article
}

extend type Mutation {
    """
    Analytic event for when the app received the {Notification}
    Deprecated in favor of Snowplow
    """
    notification_push_delivered(
        "The {Notification.user_notification_id} of the notification" cxt_notification_id: String
        "true if this notification was rolled up with other notifications and shown as a batch notification and its own details were not fully shown. False if shown completely as its own." cxt_is_grouped: Boolean
    ): Void @deprecated @figment(related_to: "NotifyFeature") @figment(related_to: "V3AnalyticsFeature") @figment(auth: "UserAuth") @figment(priority: "ASAP")

    """
    Analytic event for when the app published the {Notification} to the device's system notification ui
    Deprecated in favor of Snowplow
    """
    notification_push_published(
        "The {Notification.user_notification_id} of the notification" cxt_notification_id: String
        "true if this notification was rolled up with other notifications and shown as a batch notification and its own details were not fully shown. False if shown completely as its own." cxt_is_grouped: Boolean
    ): Void @deprecated @figment(related_to: "NotifyFeature") @figment(related_to: "V3AnalyticsFeature") @figment(auth: "UserAuth") @figment(priority: "ASAP")

    """
    Analytic event for when the user has performed one of the {Notification}'s actions ({NotificationButtonData}) by clicking a button in the system notification ui
    Deprecated in favor of Snowplow
    """
    notification_push_action(
        "The {Notification.user_notification_id} of the notification" cxt_notification_id: String
        "true if this notification was rolled up with other notifications and shown as a batch notification and its own details were not fully shown. False if shown completely as its own." cxt_is_grouped: Boolean
        "The {NotificationButton.action_name} of the action performed." cxt_action_name: String
        "The {NotificationButton.data} of the action performed. Send as a json string of the object." cxt_action_data: String
    ): Void
    @deprecated
    @figment(related_to: "NotifyFeature")
    @figment(related_to: "V3AnalyticsFeature")
    @figment(auth: "UserAuth")
    @figment(priority: "ASAP")
    @figment(effect: "Find the {Notification} by matching {Notification.user_notification_id} to {.cxt_notification_id} and find the action by matching {.cxt_action_name} with {NotificationButton.action_name} and update:")
    @figment(effect: " * Set {NotificationButton.enabled} to 0")
    @figment(effect: " * Set {NotificationButton.taken_time} to {.time}")

    """
    Analytic event for when the user has tapped/clicked a {Notification} in the system notification ui and triggered opening the {Notification.destination_url}
    Deprecated in favor of Snowplow
    """
    notification_push_opened(
        "The {Notification.user_notification_id} of the notification" cxt_notification_id: String
        "true if this notification was rolled up with other notifications and shown as a batch notification and its own details were not fully shown. False if shown completely as its own." cxt_is_grouped: Boolean
        "The {Notification.destination_url} that was opened." cxt_url: String
    ): Void @deprecated @figment(related_to: "NotifyFeature") @figment(related_to: "V3AnalyticsFeature") @figment(auth: "UserAuth") @figment(priority: "ASAP")

    """
    Analytic event for when the user has dismissed a {Notification} from the system notification ui without taking any action or clicking it
    Deprecated in favor of Snowplow
    """
    notification_push_dismissed(
        "The {Notification.user_notification_id} of the notification" cxt_notification_id: String
        "true if this notification was rolled up with other notifications and shown as a batch notification and its own details were not fully shown. False if shown completely as its own." cxt_is_grouped: Boolean
    ): Void @deprecated @figment(related_to: "NotifyFeature") @figment(related_to: "V3AnalyticsFeature") @figment(auth: "UserAuth") @figment(priority: "ASAP")

    """
    Analytic event for when the user has seen a {Notification} in the in app screen, currently called "Activity".
    Deprecated in favor of Snowplow
    """
    notification_impression(
        impressions: [NotificationImpression]
    ): Void @deprecated @figment(related_to: "NotifyFeature") @figment(related_to: "V3AnalyticsFeature") @figment(auth: "UserAuth") @figment(priority: "ASAP")

    """
    Analytic event for when the user has performed one of the {Notification}'s actions {NotificationButtonData} by clicking a button in the in app notification ui, currently called "Activity"
    Deprecated in favor of Snowplow
    """
    notification_action(
        "The {Notification.user_notification_id} of the notification" cxt_notification_id: String
        "true if this notification was rolled up with other notifications and shown as a batch notification and its own details were not fully shown. False if shown completely as its own." cxt_is_grouped: Boolean
        "The {NotificationButton.action_name} of the action performed." cxt_action_name: String
        "The {NotificationButton.data} of the action performed. Send as a json string of the object." cxt_action_data: String
    ): Void
    @deprecated
    @figment(related_to: "NotifyFeature")
    @figment(related_to: "V3AnalyticsFeature")
    @figment(auth: "UserAuth")
    @figment(priority: "ASAP")
    @figment(effect: "Find the {Notification} by matching {Notification.user_notification_id} to {.cxt_notification_id} and find the action by matching {.cxt_action_name} with {NotificationButton.action_name} and update:")
    @figment(effect: " * Set {NotificationButton.enabled} to 0")
    @figment(effect: " * Set {NotificationButton.taken_time} to {.time}")

    """
    Analytic event for when the user has tapped/clicked a {Notification} url in the in-app notification ui (currently called "Activity")
    Deprecated in favor of Snowplow
    """
    notification_opened(
        "The {Notification.user_notification_id} of the notification" cxt_notification_id: String
        "true if this notification was rolled up with other notifications and shown as a batch notification and its own details were not fully shown. False if shown completely as its own." cxt_is_grouped: Boolean
        "The url that was opened." cxt_url: String
        "\"main\" If the url is {Notification.destination_url}. \"body\" if it is from clicking a link within the notification body text within {Notification.notification_text}" cxt_ui: String
    ): Void @deprecated @figment(related_to: "NotifyFeature") @figment(related_to: "V3AnalyticsFeature") @figment(auth: "UserAuth") @figment(priority: "ASAP")
}

"""
An impression. See {notification_impression}
Deprecated in favor of Snowplow
"""
input NotificationImpression @_deprecated @figment(related_to: "V3AnalyticsFeature") {
    cxt_notification_id: String

    "1 based position within the ui"
    cxt_index: Int

    "Probably just \"notification\""
    cxt_view: String

    "Time of the impression"
    time: Timestamp
}

extend type Mutation {
    """
    Track impressions of {Item}s such as when a user views and scrolls through My List.
    Deprecated in favor of Snowplow
    """
    list_item_impression(
        impressions: [ItemImpression]
    ): Void @deprecated @figment(related_to: "V3AnalyticsFeature") @figment(related_to: "MyListFeature") @figment(auth: "UserAuth") @figment(priority: "WHENEVER")
}

"""
TODO cxt values
Deprecated in favor of Snowplow
"""
input ItemImpression @_deprecated @figment(related_to: "V3AnalyticsFeature") {
    item_id: String
    url: String
    time: Timestamp

    "1 based"
    cxt_index: Int
}

extend type Mutation {
    """
    Track when an {Item} has been fully loaded and is now visible in the reader.
    Was used as part of an investigation into spoc analytic issues, no longer needed https://pocket.slack.com/archives/C10EY0143/p1559754465002500
    """
    loaded_item(
        "If known, the {Item.item_id}. At least one of {.item_id} or {.url} must be set to identify the item to act on." item_id: String
        "If known, the {Item.given_url}. At least one of {.item_id} or {.url} must be set to identify the item to act on." url: Url
        unique_id: String
        cxt_action_detail: ReaderLoadedType
    ): Void @deprecated @figment(related_to: "V3AnalyticsFeature") @figment(auth: "UserAuth") @figment(priority: "WHENEVER")
}

"""
Deprecated in favor of Snowplow
"""
enum ReaderLoadedType @_deprecated @figment(related_to: "V3AnalyticsFeature") {
    "Some aspect of the page has become visible as it is loading"
    visual

    "The page has fully loaded"
    full
}

extend type Mutation {
    """
    Deprecated in favor of Snowplow
    Track a {Topic} was viewed TODO ui context values
    """
    opened_topic(
        cxt_topic: String
    ): Void @deprecated @figment(related_to: "V3AnalyticsFeature") @figment(related_to: "TopicsFeature") @figment(auth: "UserAuth") @figment(priority: "WHENEVER")

    """
    Deprecated in favor of Snowplow
    Track a {Topic} was loaded  TODO ui context values
    """
    loaded_topic(
        cxt_topic: String
    ): Void @deprecated @figment(related_to: "V3AnalyticsFeature") @figment(related_to: "TopicsFeature") @figment(auth: "UserAuth") @figment(priority: "WHENEVER")

    """
    Deprecated in favor of Snowplow
    Track when an {Item] has been viewed as an article view
    """
    opened_article(
        "If known, the {Item.item_id}. At least one of {.item_id} or {.url} must be set to identify the item to act on." item_id: String
        "If known, the {Item.given_url}. At least one of {.item_id} or {.url} must be set to identify the item to act on." url: Url
    ): Void @deprecated @figment(related_to: "V3AnalyticsFeature") @figment(related_to: "ArticleViewFeature") @figment(auth: "UserAuth") @figment(priority: "WHENEVER")

    """
    Deprecated in favor of Snowplow
    Track when an {Item} has been viewed as a web view
    """
    opened_web(
        "If known, the {Item.item_id}. At least one of {.item_id} or {.url} must be set to identify the item to act on." item_id: String
        "If known, the {Item.given_url}. At least one of {.item_id} or {.url} must be set to identify the item to act on." url: Url
    ): Void @deprecated @figment(related_to: "V3AnalyticsFeature") @figment(related_to: "WebViewFeature") @figment(auth: "UserAuth") @figment(priority: "WHENEVER")

    """
    Deprecated in favor of Snowplow
    Track when an {Item} has been viewed as a video
    """
    opened_video(
        "If known, the {Item.item_id}. At least one of {.item_id} or {.url} must be set to identify the item to act on." item_id: String
        "If known, the {Item.given_url}. At least one of {.item_id} or {.url} must be set to identify the item to act on." url: Url
    ): Void @deprecated @figment(related_to: "V3AnalyticsFeature") @figment(related_to: "VideosFeature") @figment(auth: "UserAuth") @figment(priority: "WHENEVER")

    """
    Deprecated in favor of Snowplow
    Track when an {Item} has been viewed as an image
    """
    opened_image(
        "If known, the {Item.item_id}. At least one of {.item_id} or {.url} must be set to identify the item to act on." item_id: String
        "If known, the {Item.given_url}. At least one of {.item_id} or {.url} must be set to identify the item to act on." url: Url
    ): Void @deprecated @figment(related_to: "V3AnalyticsFeature") @figment(related_to: "ImagesFeature") @figment(auth: "UserAuth") @figment(priority: "WHENEVER")
}

extend type Mutation {
    """
    Deprecated in favor of Snowplow
    Track when the user opens the app from it not being on screen
    """
    opened_app: Void @deprecated @figment(related_to: "V3AnalyticsFeature") @figment(auth: "UserAuth") @figment(priority: "WHENEVER")

    """
    Deprecated in favor of Snowplow
    Track when the user closes the app, switching to another, and it is no longer visible on screen.
    """
    closed_app: Void @deprecated @figment(related_to: "V3AnalyticsFeature") @figment(auth: "UserAuth") @figment(priority: "WHENEVER")
}

extend type Mutation {
    "Deprecated in favor of Snowplow"
    opened_list: Void @deprecated @figment(related_to: "V3AnalyticsFeature") @figment(related_to: "MyListFeature") @figment(auth: "UserAuth") @figment(priority: "WHENEVER")

    "Deprecated in favor of Snowplow"
    opened_feed: Void @deprecated @figment(related_to: "V3AnalyticsFeature") @figment(related_to: "DiscoverFeature") @figment(auth: "UserAuth") @figment(priority: "WHENEVER")

    "Deprecated in favor of Snowplow"
    opened_home: Void @deprecated @figment(related_to: "V3AnalyticsFeature") @figment(auth: "UserAuth") @figment(priority: "WHENEVER")

    "Deprecated in favor of Snowplow"
    opened_search: Void @deprecated @figment(related_to: "V3AnalyticsFeature") @figment(related_to: "SearchFeature") @figment(auth: "UserAuth") @figment(priority: "WHENEVER")

    """
    Deprecated in favor of Snowplow
    Track a view of the list of {Notification}s
    """
    opened_notifications_view: Void @deprecated @figment(related_to: "V3AnalyticsFeature") @figment(related_to: "NotifyFeature") @figment(auth: "UserAuth") @figment(priority: "WHENEVER")

    "Deprecated in favor of Snowplow"
    opened_profile(
        "uid of {Profile} viewed" cxt_user_id: String
    ): Void @deprecated @figment(related_to: "V3AnalyticsFeature") @figment(related_to: "SocialFeature") @figment(auth: "UserAuth") @figment(priority: "WHENEVER")

    "Deprecated in favor of Snowplow"
    listen_opened(
        "The {Item.id_url} of the item being listened to" url: Url
    ): Void @deprecated @figment(related_to: "V3AnalyticsFeature") @figment(related_to: "ListenFeature") @figment(auth: "UserAuth") @figment(priority: "WHENEVER")

    "Deprecated in favor of Snowplow"
    start_listen(
        "The {Item.id_url} of the item being listened to" url: Url
    ): Void @deprecated @figment(related_to: "V3AnalyticsFeature") @figment(related_to: "ListenFeature") @figment(auth: "UserAuth") @figment(priority: "WHENEVER")

    "Deprecated in favor of Snowplow"
    pause_listen(
        "The {Item.id_url} of the item being listened to" url: Url
    ): Void @deprecated @figment(related_to: "V3AnalyticsFeature") @figment(related_to: "ListenFeature") @figment(auth: "UserAuth") @figment(priority: "WHENEVER")

    "Deprecated in favor of Snowplow"
    resume_listen(
        "The {Item.id_url} of the item being listened to" url: Url
    ): Void @deprecated @figment(related_to: "V3AnalyticsFeature") @figment(related_to: "ListenFeature") @figment(auth: "UserAuth") @figment(priority: "WHENEVER")

    "Deprecated in favor of Snowplow"
    rewind_listen(
        "The {Item.id_url} of the item being listened to" url: Url
        "Position in seconds from the beginning of the track" cxt_scroll_amount: Int
    ): Void @deprecated @figment(related_to: "V3AnalyticsFeature") @figment(related_to: "ListenFeature") @figment(auth: "UserAuth") @figment(priority: "WHENEVER")

    """
    Deprecated in favor of Snowplow
    TTS analytics
    """
    stop_listen(
        "The {Item.id_url} of the item being listened to" url: Url
    ): Void @deprecated @figment(related_to: "V3AnalyticsFeature") @figment(related_to: "ListenFeature") @figment(auth: "UserAuth") @figment(priority: "WHENEVER")

    "Deprecated in favor of Snowplow"
    fast_forward_listen(
        "The {Item.id_url} of the item being listened to" url: Url
        "Position in seconds from the beginning of the track" cxt_scroll_amount: Int
    ): Void @deprecated @figment(related_to: "V3AnalyticsFeature") @figment(related_to: "ListenFeature") @figment(auth: "UserAuth") @figment(priority: "WHENEVER")

    "Deprecated in favor of Snowplow"
    skip_next_listen(
        "The {Item.id_url} of the item being listened to" url: Url
    ): Void @deprecated @figment(related_to: "V3AnalyticsFeature") @figment(related_to: "ListenFeature") @figment(auth: "UserAuth") @figment(priority: "WHENEVER")

    "Deprecated in favor of Snowplow"
    skip_back_listen(
        "The {Item.id_url} of the item being listened to" url: Url
    ): Void @deprecated @figment(related_to: "V3AnalyticsFeature") @figment(related_to: "ListenFeature") @figment(auth: "UserAuth") @figment(priority: "WHENEVER")

    "Deprecated in favor of Snowplow"
    listen_closed(
        "The {Item.id_url} of the item being listened to" url: Url
    ): Void @deprecated @figment(related_to: "V3AnalyticsFeature") @figment(related_to: "ListenFeature") @figment(auth: "UserAuth") @figment(priority: "WHENEVER")

    "Deprecated in favor of Snowplow"
    reach_end_listen(
        "The {Item.item_id} of the item being listened to." item_id: String
    ): Void @deprecated @figment(related_to: "V3AnalyticsFeature") @figment(related_to: "ListenFeature") @figment(auth: "UserAuth") @figment(priority: "WHENEVER")
}

extend type Mutation {
    """
    Deprecated in favor of Snowplow
    Track a choice from the share menu
    """
    shared(
        "The {Item.id_url} of the item being shared" url: String
        service: String
    ): Void @deprecated @figment(related_to: "V3AnalyticsFeature") @figment(related_to: "SharingFeature") @figment(auth: "UserAuth") @figment(priority: "WHENEVER")
}

extend type Mutation {
    """
    Track an analytical event. Mostly view and click events. Does not change user state, only used for analytics.
    Deprecated in favor of Snowplow
    """
    pv(
        section: CxtSection
        view: CxtView
        event: CxtEvent
        version: String
        event_type: Int
        event_id_x: Int
        event_id_y: Int
        event_id_z: Int
    ): Void @deprecated @figment(related_to: "V3AnalyticsFeature") @figment(auth: "GuidAuth") @figment(priority: "WHENEVER")
}

extend type Mutation {
    """
    Track view of a publisher message.
    See deprecation notes in Publisher Messaging. If we continue any similar analytics they should use Snowplow
    """
    pmv(
        pkta: String
        "If known, the {Item.id_url}. At least one of {.item_id} or {.url} must be set to identify the item to act on." url: Url
        "If known, the {Item.item_id}. At least one of {.item_id} or {.url} must be set to identify the item to act on." item_id: String
    ): Void @deprecated @figment(related_to: "V3AnalyticsFeature") @figment(related_to: "PublisherMessagingFeature") @figment(auth: "UserAuth") @figment(priority: "WHENEVER")

    """
    Track clicks on publisher message links.
    See deprecation notes in Publisher Messaging. If we continue any similar analytics they should use Snowplow
    """
    pmc(
        pkta: String
        "If known, the {Item.id_url}. At least one of {.item_id} or {.url} must be set to identify the item to act on." url: Url
        click_url: String
        "If known, the {Item.item_id}. At least one of {.item_id} or {.url} must be set to identify the item to act on." item_id: String
    ): Void @deprecated @figment(related_to: "V3AnalyticsFeature") @figment(related_to: "PublisherMessagingFeature") @figment(auth: "UserAuth") @figment(priority: "WHENEVER")

    """
    Track clicks on publisher message links. TODO what diff with pmc "wasPocketed" is maybe a hint?
    See deprecation notes in Publisher Messaging. If we continue any similar analytics they should use Snowplow
    """
    pmp(
        pkta: String
        "If known, the {Item.id_url}. At least one of {.item_id} or {.url} must be set to identify the item to act on." url: Url
        click_url: String
        "If known, the {Item.item_id}. At least one of {.item_id} or {.url} must be set to identify the item to act on." item_id: String
    ): Void @deprecated @figment(related_to: "V3AnalyticsFeature") @figment(related_to: "PublisherMessagingFeature") @figment(auth: "UserAuth") @figment(priority: "WHENEVER")
}

extend type Mutation {
    """
    Deprecated in favor of Snowplow
    Fired anytime a user is viewing the item's content in the Reader and makes an explicit action to close or change which item/page they are viewing. Such as:
    1. Internally navigating to a new page by clicking a link. (While in item A, they tap a link that opens page B, a left_item fires for A)
    2. Navigating backward from a link like above (While in B, they tap back to return to A, left_item fires for B)
    3. Closing/exiting the reader to return to the previous screen, such as my list. (this does NOT include “pausing” such as leaving the app or going into a sub screen like tagging.) This can happen by tapping the back button while on the original item A, or while on the original item A taking an action like Archive or Delete that auto closes the item.
    left_item should not be triggered for state changes of the same item, such as refreshing an item, retrying an item that failed to load, or toggling between article/web views.
    """
    left_item(
        "If known, the {Item.item_id}. At least one of {.item_id} or {.url} must be set to identify the item to act on." item_id: String
        "If known, the {Item.id_url}. At least one of {.item_id} or {.url} must be set to identify the item to act on." url: Url
    ): Void @deprecated @figment(related_to: "V3AnalyticsFeature") @figment(auth: "UserAuth") @figment(priority: "WHENEVER")
}

extend type Mutation {
    """
    Deprecated in favor of Snowplow
    Track when a Carousel item is viewed by the user (impression) TODO is this still used?
    """
    item_impression(
        "If known, the {Item.item_id}. At least one of {.item_id} or {.url} must be set to identify the item to act on." item_id: String
        "If known, the {Item.id_url}. At least one of {.item_id} or {.url} must be set to identify the item to act on." url: Url
    ): Void @deprecated @figment(related_to: "V3AnalyticsFeature") @figment(auth: "UserAuth") @figment(priority: "WHENEVER")
}

extend type Mutation {
    """
    Deprecated in favor of Snowplow
    Track when an {Group} filter is viewed
    """
    group_open: Void @deprecated @figment(related_to: "V3AnalyticsFeature") @figment(related_to: "BadgesFeature") @figment(auth: "UserAuth") @figment(priority: "WHENEVER")
}

extend type Mutation {
    """
    Deprecated in favor of Snowplow
    Track when a Highlights is viewed. TODO is this used anymore?
    """
    highlights_impression(
        "comma delim'd string of group ids visible at the time of the impression" ids: String
    ): Void @deprecated @figment(related_to: "V3AnalyticsFeature") @figment(related_to: "BadgesFeature") @figment(related_to: "RediscoveryFeature") @figment(auth: "UserAuth") @figment(priority: "WHENEVER")
}

extend type Mutation {
    """
    Deprecated in favor of Snowplow
    Track when a search is performed locally
    """
    search(
        state: ItemStatusKey
        shared: Boolean
        contentType: ItemContentType
        favorite: Boolean
        sort: ItemSortKey
        tag: String
        "max length 100" search: String
        "how many results" resultsCnt: Int
    ): Void @deprecated @figment(related_to: "V3AnalyticsFeature") @figment(related_to: "SearchFeature") @figment(auth: "UserAuth") @figment(priority: "WHENEVER")

    """
    Deprecated in favor of Snowplow
    Track when Explore Search results are loaded
    """
    loaded_search: Void @deprecated @figment(related_to: "V3AnalyticsFeature") @figment(related_to: "SearchFeature") @figment(auth: "UserAuth") @figment(priority: "WHENEVER")
}

extend type Mutation {
    """
    Deprecated in favor of Snowplow
    Track a page view or an event. Note there are some cases where there are additional parameters
    """
    pv_wt(
        view: CxtView
        type_id: Int
        section: CxtSection
        page: CxtPage
        action_identifier: CxtEvent
        page_params: String
        source: CxtSource
        "Only used for {UserMessage} analytics." reason_code: UserMessageResult
    ): Void @deprecated @figment(related_to: "V3AnalyticsFeature") @figment(auth: "GuidAuth") @figment(priority: "WHENEVER")
}

extend type Mutation {
    """
    Deprecated in favor of Snowplow
    Track a view of a ExtendedAttribution TODO is this only for ExtendedAttribution? if so, can deprecate
    """
    attribution_view: Void @deprecated @figment(related_to: "V3AnalyticsFeature") @figment(related_to: "AttributionFeature") @figment(auth: "UserAuth") @figment(priority: "WHENEVER")

    """
    Deprecated in favor of Snowplow
    Track a view of a ExtendedAttribution TODO is this only for ExtendedAttribution? if so, can deprecate
    """
    attribution_action: Void @deprecated @figment(related_to: "V3AnalyticsFeature") @figment(related_to: "AttributionFeature") @figment(auth: "UserAuth") @figment(priority: "WHENEVER")
}

extend type Mutation {
    """
    Request the server turns on Third Party Analytic sending. Ask Server Ops Team for more details.
    TODO still used?
    """
    tpa_start(
        service_id: String
    ): Void @deprecated @figment(related_to: "V3AnalyticsFeature") @figment(auth: "UserAuth") @figment(priority: "ASAP")

    """
    Request the server turns off  Third Party Analytic sending. Ask Server Ops Team for more details.
    TODO still used?
    """
    tpa_stop(
        service_id: String
    ): Void @deprecated @figment(related_to: "V3AnalyticsFeature") @figment(auth: "UserAuth") @figment(priority: "ASAP")
}

extend type Mutation {
    """
    Deprecated in favor of Snowplow
    Track an impression of a {FeedItem}
    """
    feed_item_impression(
        impressions: [FeedItemImpressionData]
    ): Void @deprecated @figment(related_to: "V3AnalyticsFeature") @figment(related_to: "DiscoverFeature") @figment(auth: "UserAuth") @figment(priority: "WHENEVER")
}

"""
Deprecated in favor of Snowplow
Information about an impression of a {FeedItem}
"""
input FeedItemImpressionData @_deprecated @figment(related_to: "V3AnalyticsFeature") {
    "The {FeedItem.feed_item_id} of the item viewed"
    cxt_feed_item: String

    "The {FeedItem.item.item_id} of the item viewed"
    cxt_item_id: String

    "The {FeedItem.item.item_id} of the item viewed. It looks like this is used, not the {.cxt_item_id} one. TODO clarify"
    item_id: String

    "The {FeedItem.post.post_id} of the item viewed, if there is a post on the item"
    cxt_post_id: String

    "1 based position in the feed of the item that was viewed"
    cxt_index: Int

    "When the impression occurred"
    time: Timestamp
}

extend type Mutation {
    "Track an impression of a Layout"
    layout_impression(
        impressions: [ActionContext]
    ): Void @deprecated @figment(related_to: "V3AnalyticsFeature") @figment(auth: "UserAuth") @figment(priority: "WHENEVER")
}

extend type Mutation {
    """
    Deprecated in favor of Snowplow
    Track start of an item session
    """
    item_session_start(
        "Id of the item session" item_session_id: String
        "How the item session was started" trigger_event: ItemSessionTriggerEvent
        "If known, the {Item.item_id}. At least one of {.item_id} or {.url} must be set to identify the item to act on." item_id: String
        "If known, the {Item.id_url}. At least one of {.item_id} or {.url} must be set to identify the item to act on." url: Url
    ): Void @deprecated @figment(related_to: "ItemSessionsFeature") @figment(auth: "UserAuth") @figment(priority: "WHENEVER")
}

enum ItemSessionTriggerEvent @figment(related_to: "ItemSessionsFeature") {
    opened_article
    opened_web
    opened_video

    "Pressed back arrow and returned to list/home/feed"
    closed_reader

    "Archive"
    read

    "Delete"
    deleted

    "Opened_app in Reader view and there is not an active item session ID (i.e. user waited more than 3 minutes before returning to app)"
    opened_app

    "App moves to background"
    closed_app

    "User opens link in item"
    opened_link

    "Pressed back arrow, closing link and returning to previous item"
    closed_link

    "User has article with attribution open and clicks on originating user's profile"
    opened_profile

    "User returns to article with attribution after clicking on originating user's profile"
    closed_profile

    "User opens the fullscreen Listen player"
    opened_listen

    "User starts Listen"
    start_listen

    "User un-pauses Listen via player controls"
    resume_listen

    """
    User changes track with the "skip next" button
    """
    skip_next_listen

    """
    User changes track with the "skip back" button
    """
    skip_back_listen

    "User pauses Listen"
    pause_listen

    "User reaches end of current item"
    reach_end_listen

    "User closes the fullscreen Listen player"
    closed_listen

    "An error interrupts the session"
    error
}

extend type Mutation {
    """
    Deprecated in favor of Snowplow
    Track pause (soft-close) of an item session
    """
    item_session_pause(
        "Id of the item session" item_session_id: String
        "Time user spent consuming content" time_spent: Int
        "How the item session was paused" trigger_event: ItemSessionTriggerEvent
        "If known, the {Item.item_id}. At least one of {.item_id} or {.url} must be set to identify the item to act on." item_id: String
        "If known, the {Item.id_url}. At least one of {.item_id} or {.url} must be set to identify the item to act on." url: Url
    ): Void @deprecated @figment(related_to: "ItemSessionsFeature") @figment(auth: "UserAuth") @figment(priority: "WHENEVER")

    """
    Deprecated in favor of Snowplow
    Track continuation of a previously paused item session
    """
    item_session_continue(
        "Id of the item session" item_session_id: String
        "How the item session was continued" trigger_event: ItemSessionTriggerEvent
        "If known, the {Item.item_id}. At least one of {.item_id} or {.url} must be set to identify the item to act on." item_id: String
        "If known, the {Item.id_url}. At least one of {.item_id} or {.url} must be set to identify the item to act on." url: Url
    ): Void @deprecated @figment(related_to: "ItemSessionsFeature") @figment(auth: "UserAuth") @figment(priority: "WHENEVER")

    """
    Deprecated in favor of Snowplow
    Track end (hard-close) of an item session
    """
    item_session_end(
        "Id of the item session" item_session_id: String
        "Time user spent consuming content" time_spent: Int
        "How the item session was ended" trigger_event: ItemSessionTriggerEvent
        "If known, the {Item.item_id}. At least one of {.item_id} or {.url} must be set to identify the item to act on." item_id: String
        "If known, the {Item.id_url}. At least one of {.item_id} or {.url} must be set to identify the item to act on." url: Url
    ): Void @deprecated @figment(related_to: "ItemSessionsFeature") @figment(auth: "UserAuth") @figment(priority: "WHENEVER")
}

extend type Mutation {
    """
    Very old analytics format.
    Deprecated https://pocket.slack.com/archives/C067Y2396/p1547504425125400
    """
    stat(
        "Campaign" c: Int
        "Model" m: Int
        "Version" v: Int
        "Stage" s: Int
    ): Void @deprecated @figment(related_to: "V3AnalyticsFeature") @figment(auth: "UserAuth") @figment(address: "stat")

    """
    Deprecated in favor of Snowplow
    Very old analytics format. Not sure if still even used? TODO find out.
    """
    trackValue(
        v: Int
        value: String
    ): Void @deprecated @figment(related_to: "V3AnalyticsFeature") @figment(auth: "UserAuth") @figment(address: "trackValue")
}
